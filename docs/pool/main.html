<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="../styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="../Token.html">Token</a></li></li><li><li><a href="../ckbtctest/main.html">ckbtctest/main</a></li></li><li><li><a href="../defi/main.html">defi/main</a></li></li><li><li><a href="../defi/types.html">defi/types</a></li></li><li><li><a href="../lokbtc/main.html">lokbtc/main</a></li></li><li><li><a href="../pool/main.html">pool/main</a></li></li><li><li><a href="../pool/types.html">pool/types</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Miner">Miner</a></li></li></ul></nav><div class="documentation"><h1>pool/main</h1><div class="declaration"><h4 class="class-declaration" id="type.Miner"><span class="keyword">actor </span><span class="keyword">class </span><span class="classname">Miner</span>()</h4><div class="declaration"><h4 class="function" id="Miner.getCurrentScheduler"><code><span class="keyword">public func </span><span class="fnname">getCurrentScheduler</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.logError"><code><span class="keyword">public func </span><span class="fnname">logError</span>(<span class="parameter">errorMessage</span> : <span class="type">Text</span>, <span class="parameter">username</span> : <span class="type">Text</span>) : <span class="keyword">async </span>()</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getICPTimeString"><code><span class="keyword">public func </span><span class="fnname">getICPTimeString</span>() : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getNext"><code><span class="keyword">public func </span><span class="fnname">getNext</span>() : <span class="keyword">async </span><span class="type">Int</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.compareNow"><code><span class="keyword">public func </span><span class="fnname">compareNow</span>() : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getStamp"><code><span class="keyword">public func </span><span class="fnname">getStamp</span>() : <span class="keyword">async </span><span class="type">Int</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getShareList"><code><span class="keyword">public func </span><span class="fnname">getShareList</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, [(<span class="type">Text</span>, <a href="types.html#type.RevenueShare"><span class="type">T.RevenueShare</span></a>)])]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getReceivedShareList"><code><span class="keyword">public func </span><span class="fnname">getReceivedShareList</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, [(<span class="type">Text</span>, <a href="types.html#type.RevenueShare"><span class="type">T.RevenueShare</span></a>)])]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.initialDistributionHour"><code><span class="keyword">public func </span><span class="fnname">initialDistributionHour</span>() : <span class="keyword">async </span><span class="type">Int</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getCounter"><code><span class="keyword">public func </span><span class="fnname">getCounter</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.stopScheduler"><code><span class="keyword">public func </span><span class="fnname">stopScheduler</span>(<span class="parameter">id_</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.init"><code><span class="keyword">public func </span><span class="fnname">init</span>(<span class="parameter">fetchNewTime</span> : <span class="type">Bool</span>) : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.migrateJwallet"><code><span class="keyword">public func </span><span class="fnname">migrateJwallet</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <span class="type">Text</span>)]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.enableDistribution"><code><span class="keyword">public func </span><span class="fnname">enableDistribution</span>(<span class="parameter">enable</span> : <span class="type">Bool</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setTS_"><code><span class="keyword">public func </span><span class="fnname">setTS_</span>(<span class="parameter">ts</span> : <span class="type">Int</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.clearData"><code><span class="keyword">public func </span><span class="fnname">clearData</span>() : <span class="keyword">async </span>()</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.clearDistribution"><code><span class="keyword">public func </span><span class="fnname">clearDistribution</span>() : <span class="keyword">async </span>()</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.isNotPaused"><code><span class="keyword">public func </span><span class="fnname">isNotPaused</span>() : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setCKBTCVault"><code><span class="keyword">public func </span><span class="fnname">setCKBTCVault</span>(<span class="parameter">vault_</span> : <span class="type">Principal</span>) : <span class="keyword">async </span><span class="type">Principal</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setJwalletVault"><code><span class="keyword">public func </span><span class="fnname">setJwalletVault</span>(<span class="parameter">vault_</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setMinerCKBTCVault"><code><span class="keyword">public func </span><span class="fnname">setMinerCKBTCVault</span>(<span class="parameter">vault_</span> : <span class="type">Principal</span>) : <span class="keyword">async </span><span class="type">Principal</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getCurrentIndex"><code><span class="keyword">public func </span><span class="fnname">getCurrentIndex</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.pauseCanister"><code><span class="keyword">public func </span><span class="fnname">pauseCanister</span>(<span class="parameter">pause_</span> : <span class="type">Bool</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.isVerified"><code><span class="keyword">public func </span><span class="fnname">isVerified</span>(<span class="parameter">p</span> : <span class="type">Principal</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p><p>The <code>isVerified</code> function is a public query function that checks if a miner associated with a given principal is verified. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public query</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes a single parameter <code>p</code> of type <code>Principal</code>, which represents the principal of the miner.</li><li>The function returns a <code>Bool</code> indicating whether the miner is verified (<code>true</code>) or not (<code>false</code>).</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(p)</code> to retrieve the miner associated with the given principal.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function returns <code>false</code>.</li><li>If the result is <code>#ok(m)</code>, it means the miner exists, and the miner's data is stored in the variable <code>m</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatusAndRewardHash.get(Nat.toText(m.id))</code>.</li></ul></li><li><strong>Check Verification Status</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner's status exists:<ul><li>If the result is <code>?m</code>, it means the miner's status exists, and the function returns the <code>verified</code> field of the miner's status.</li><li>If the result is <code>null</code>, it means the miner's status does not exist, and the function returns <code>false</code>.</li></ul></li></ul></li></ol>

<p>In summary, the <code>isVerified</code> function checks if a miner associated with a given principal is verified by retrieving the miner's status and returning the <code>verified</code> field. If the miner or the miner's status does not exist, the function returns <code>false</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.setDappsKey"><code><span class="keyword">public func </span><span class="fnname">setDappsKey</span>(<span class="parameter">key</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setF2PoolKey"><code><span class="keyword">public func </span><span class="fnname">setF2PoolKey</span>(<span class="parameter">key</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.access"><code><span class="keyword">public func </span><span class="fnname">access</span>() : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.geta"><code><span class="keyword">public func </span><span class="fnname">geta</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.toggleRoutine"><code><span class="keyword">public func </span><span class="fnname">toggleRoutine</span>(<span class="parameter">b_</span> : <span class="type">Bool</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getBalance"><code><span class="keyword">public func </span><span class="fnname">getBalance</span>() : <span class="keyword">async </span>{ currentBalance : <span class="type">Nat</span>; withdrawn : <span class="type">Nat</span>; total : <span class="type">Nat</span>; claimables : <span class="type">Nat</span> }</code></h4><p><p>The <code>getBalance</code> function is a public query function that retrieves the current balance, total withdrawn, total balance, and claimable balances for all miners.
Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public query</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes no parameters.</li><li>The function returns an object with four fields:<ul><li><code>currentBalance</code>: The current total balance of all miners.</li><li><code>withdrawn</code>: The total amount withdrawn by all miners.</li><li><code>total</code>: The sum of the current balance and the total withdrawn.</li><li><code>claimables</code>: The total claimable balance of all miners.</li></ul></li></ul></li><li><strong>Retrieve User List</strong>:<ul><li>The function retrieves all entries from <code>usernameHash</code> and converts them to an array <code>ls</code>.</li></ul></li><li><strong>Initialize Total Revenue</strong>:<ul><li>The function initializes a variable <code>totalRev</code> to 0, which will be used to accumulate the total claimable balance.</li></ul></li><li><strong>Loop Through Users</strong>:<ul><li>The function iterates over each user in <code>ls</code>.</li></ul></li><li><strong>Get Miner and Status</strong>:<ul><li>For each user, the function retrieves the miner's data using <code>miners.get(usr.1)</code> and stores it in the variable <code>miner</code>.</li><li>It retrieves the miner's status using <code>minerStatus.get(miner_.id)</code> and stores it in the variable <code>minerStat</code>.</li></ul></li><li><strong>Accumulate Claimable Balance</strong>:<ul><li>The function adds the miner's balance (<code>minerStat_.balance</code>) to <code>totalRev</code>.</li></ul></li><li><strong>Return Balances</strong>:<ul><li>The function returns an object with the following fields:<ul><li><code>currentBalance</code>: The value of <code>totalBalance</code>.</li><li><code>withdrawn</code>: The value of <code>totalWithdrawn</code>.</li><li><code>total</code>: The sum of <code>totalWithdrawn</code> and <code>totalBalance</code>.</li><li><code>claimables</code>: The accumulated total claimable balance (<code>totalRev</code>).</li></ul></li></ul></li></ol>

<p>In summary, the <code>getBalance</code> function retrieves and returns the current balance, total withdrawn, total balance, and claimable balances for all miners. It iterates through the list of users, retrieves each miner's balance, and accumulates the claimable balances.
The function ensures that the data is returned in a structured format.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getDistributionList"><code><span class="keyword">public func </span><span class="fnname">getDistributionList</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <a href="types.html#type.Distribution"><span class="type">T.Distribution</span></a>)]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.withdrawalList"><code><span class="keyword">public func </span><span class="fnname">withdrawalList</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <a href="types.html#type.WithdrawalHistory"><span class="type">T.WithdrawalHistory</span></a>)]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.failedWithdrawalList"><code><span class="keyword">public func </span><span class="fnname">failedWithdrawalList</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <a href="types.html#type.WithdrawalHistory"><span class="type">T.WithdrawalHistory</span></a>)]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getCKBTCBalance"><code><span class="keyword">public func </span><span class="fnname">getCKBTCBalance</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.Utxo"><span class="keyword">type </span><span class="type">Utxo</span> = { height : <span class="type">Nat32</span>; value : <span class="type">Nat64</span>; outpoint : { txid : <span class="type">Blob</span>; vout : <span class="type">Nat32</span> } }</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.UtxoStatus"><span class="keyword">type </span><span class="type">UtxoStatus</span> = {#ValueTooSmall : <span class="type">Utxo</span>; #Tainted : <span class="type">Utxo</span>; #Minted : { minted_amount : <span class="type">Nat64</span>; block_index : <span class="type">Nat64</span>; utxo : <span class="type">Utxo</span> }; #Checked : <span class="type">Utxo</span>}</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.PendingUtxo"><span class="keyword">type </span><span class="type">PendingUtxo</span> = { confirmations : <span class="type">Nat32</span>; value : <span class="type">Nat64</span>; outpoint : { txid : <span class="type">Blob</span>; vout : <span class="type">Nat32</span> } }</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.UpdateBalanceError"><span class="keyword">type </span><span class="type">UpdateBalanceError</span> = {#GenericError : { error_message : <span class="type">Text</span>; error_code : <span class="type">Nat64</span> }; #TemporarilyUnavailable : <span class="type">Text</span>; #AlreadyProcessing; #NoNewUtxos : { required_confirmations : <span class="type">Nat32</span>; pending_utxos : ?[<span class="type">PendingUtxo</span>]; current_confirmations : ?<span class="type">Nat32</span> }}</h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.updateBalance"><code><span class="keyword">public func </span><span class="fnname">updateBalance</span>() : <span class="keyword">async </span>{#Ok : [<span class="type">UtxoStatus</span>]; #Err : <span class="type">UpdateBalanceError</span>}</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.sendCKBTC"><code><span class="keyword">public func </span><span class="fnname">sendCKBTC</span>(<br/>  <span class="parameter">wallet_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">subAccount</span> : <span class="type">Text</span>, <br/>  <span class="parameter">amount_</span> : <span class="type">Nat</span><br/>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p><p>var ckBTCBalance : Nat= (await CKBTC.icrc1_balance_of({owner=Principal.fromActor(this);subaccount=null}));
The <code>sendCKBTC</code> function is a public shared asynchronous function that transfers a specified amount of ckBTC to a given wallet. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes three parameters:<ul><li><code>wallet</code>: The wallet address to which the ckBTC will be sent (as <code>Text</code>).</li><li><code>subAccount</code>: The sub-account associated with the wallet (as <code>Text</code>).</li><li><code>amount</code>: The amount of ckBTC to be transferred (as <code>Nat</code>).</li></ul></li><li>The function returns a <code>Bool</code> indicating the success (<code>true</code>) or failure (<code>false</code>) of the transfer.</li></ul></li><li><strong>Convert Wallet Address</strong>:<ul><li>The function converts the <code>wallet</code> text to a <code>Principal</code> type using <code>Principal.fromText(wallet)</code>.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Amount Check</strong>:<ul><li>The function ensures that the amount to be transferred is greater than 0 by calling <code>assert(amount &gt; 0)</code>.</li></ul></li><li><strong>Get Current ckBTC Balance</strong>:<ul><li>The function retrieves the current ckBTC balance of the actor using <code>CKBTC.icrc1_balance_of</code>.</li><li>The balance is stored in the variable <code>ckBTCBalance</code>.</li></ul></li><li><strong>Deduct Fixed Fee</strong>:<ul><li>The function deducts a fixed fee (e.g., 12 units) from the balance by subtracting 12 from <code>ckBTCBalance</code>.</li></ul></li><li><strong>Perform the Transfer</strong>:<ul><li>The function performs the transfer using <code>CKBTC.icrc1_transfer</code> with the following details:<ul><li><code>amount</code>: The amount of ckBTC to be transferred.</li><li><code>fee</code>: An optional fee of 10 units.</li><li><code>created_at_time</code>: Not set (null).</li><li><code>from_subaccount</code>: Not set (null).</li><li><code>to</code>: The destination wallet and sub-account.</li><li><code>memo</code>: Not set (null).</li></ul></li></ul></li><li><strong>Handle the Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it returns <code>true</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it sets <code>res</code> to 0.</li></ul></li></ul></li><li><strong>Return Default Value</strong>:<ul><li>The function returns <code>true</code> by default (consider revising this logic).</li></ul></li></ol>

<p>In summary, the <code>sendCKBTC</code> function transfers a specified amount of ckBTC to a given wallet, ensuring that the caller is an admin and the amount is greater than 0.
It retrieves the current ckBTC balance, deducts a fixed fee, performs the transfer, and handles the transfer result.
The function returns <code>true</code> if the transfer is successful and <code>true</code> by default (consider revising this logic).</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getJwalletId"><code><span class="keyword">public func </span><span class="fnname">getJwalletId</span>(<span class="parameter">type_</span> : <span class="type">Text</span>, <span class="parameter">acc_</span> : <span class="type">Text</span>) : <span class="keyword">async </span>{#uuid : <span class="type">Text</span>; #none : <span class="type">Text</span>}</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.recordJwalletId"><code><span class="keyword">public func </span><span class="fnname">recordJwalletId</span>(<br/>  <span class="parameter">type_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">acc_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">uuid_</span> : <span class="type">Text</span><br/>) : <span class="keyword">async </span>{#exist : <span class="type">Text</span>; #ok}</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getCKBTCMinter"><code><span class="keyword">public func </span><span class="fnname">getCKBTCMinter</span>() : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.withdrawIDR"><code><span class="keyword">public func </span><span class="fnname">withdrawIDR</span>(<br/>  <span class="parameter">quoteId_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">amount_</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">bankID_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">memoParam_</span> : [<span class="type">Nat8</span>]<br/>) : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>withdrawIDR</code> function is a public shared asynchronous function that handles the withdrawal of IDR (Indonesian Rupiah) for a miner. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes four parameters:<ul><li><code>quoteId</code>: The quote ID associated with the withdrawal.</li><li><code>amount</code>: The amount of IDR to be withdrawn.</li><li><code>bankID</code>: The bank ID to which the IDR will be sent.</li><li><code>memoParam</code>: An array of <code>Nat8</code> representing the memo parameter.</li></ul></li><li>The function returns a <code>T.TransferRes</code> indicating the result of the withdrawal.</li></ul></li><li><strong>Pause Check</strong>:<ul><li>The function ensures that the system is not paused by calling <code>assert(_isNotPaused())</code>.</li></ul></li><li><strong>Address Verification</strong>:<ul><li>The function ensures that the caller's address is verified by calling <code>assert(_isAddressVerified(message.caller))</code>.</li></ul></li><li><strong>Amount Check</strong>:<ul><li>The function ensures that the amount is greater than 10 by calling <code>assert(amount_ &gt; 10)</code>.</li></ul></li><li><strong>Increment Withdrawal Index</strong>:<ul><li>The function increments the <code>withdrawalIndex</code> by 1.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(message.caller)</code> to retrieve the miner associated with the caller.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it returns an error indicating that the miner is not found.</li><li>If the result is <code>#ok(m)</code>, it assigns the miner's ID to <code>id</code> and the miner's username to <code>usernm</code>.</li></ul></li></ul></li><li><strong>Encode Memo</strong>:<ul><li>The function encodes the memo using <code>Text.encodeUtf8</code> and stores it in the variable <code>memo</code>.</li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>minerStatus</code>.</li></ul></li><li><strong>Check Sufficient Balance</strong>:<ul><li>The function checks if the miner has sufficient balance to cover the withdrawal amount plus a fee of 10 units.</li><li>If the balance is insufficient, it returns an error indicating the insufficient balance.</li></ul></li><li><strong>Convert Memo Parameter to Blob</strong>:<ul><li>The function converts the memo parameter to a <code>Blob</code> using <code>Blob.fromArray</code> and stores it in the variable <code>blob</code>.</li></ul></li><li><strong>Define CKBTC Actor</strong>:<ul><li>The function defines an actor <code>CKBTC</code> with the method <code>icrc1_transfer</code>.</li></ul></li><li><strong>Log Pre-Transfer Transaction</strong>:<ul><li>The function logs the pre-transfer transaction by calling <code>logTransaction</code>.</li></ul></li><li><strong>Update Balances and Total Withdrawn</strong>:<ul><li>The function updates the miner's balance, total withdrawn, and total shared revenue by subtracting the withdrawal amount plus the fee.</li><li>It also updates the global <code>totalBalance</code> and <code>totalWithdrawn</code>.</li></ul></li><li><strong>Update Miner Status and Reward Hash</strong>:<ul><li>The function updates the <code>minerStatusAndRewardHash</code> with the new miner status.</li></ul></li><li><strong>Create Withdrawal History Entry</strong>:<ul><li>The function creates a <code>T.WithdrawalHistory</code> record with the withdrawal details and stores it in the variable <code>wdh</code>.</li></ul></li><li><strong>Update Withdrawal Hash</strong>:<ul><li>The function updates the <code>withdrawalHash</code> and <code>allWithdrawalHash</code> with the new withdrawal history.</li></ul></li><li><strong>Perform Transfer</strong>:<ul><li>The function attempts to perform the transfer using the <code>CKBTC_.icrc1_transfer</code> method.</li><li>If an error occurs during the transfer, it reverts the balance updates, logs the failed transaction, and returns an error indicating the failure.</li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it logs the successful transaction, updates the <code>allSuccessfulWithdrawalHash</code>, and returns <code>#success(amount_)</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it reverts the balance updates, logs the failed transaction, and returns an error with the error message.</li></ul></li></ul></li></ol>

<p>In summary, the <code>withdrawIDR</code> function handles the withdrawal of IDR for a miner, ensuring that the system is not paused, the caller's address is verified, and the miner has sufficient balance.
It logs the transaction, updates the relevant balances, performs the transfer, and handles various error cases.
If the withdrawal is successful, it logs the transaction and returns the success result.
If any errors occur, it reverts the balance updates and returns an error.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getErrorLogs"><code><span class="keyword">public func </span><span class="fnname">getErrorLogs</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <a href="types.html#type.ErrorLog"><span class="type">T.ErrorLog</span></a>)]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getAllWithdrawals"><code><span class="keyword">public func </span><span class="fnname">getAllWithdrawals</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <a href="types.html#type.WithdrawalHistory"><span class="type">T.WithdrawalHistory</span></a>)]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getTotalRevenue"><code><span class="keyword">public func </span><span class="fnname">getTotalRevenue</span>(<span class="parameter">principal</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p><p>The <code>getTotalRevenue</code> function is a public shared asynchronous function that calculates and returns the total revenue of a specific miner, excluding adjustments. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>principal</code> of type <code>Text</code>, which represents the principal of the miner.</li><li>The function returns a <code>Nat</code> value representing the total revenue of the specified miner, excluding adjustments.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(Principal.fromText(principal))</code> to retrieve the miner associated with the given principal.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function returns 0.</li><li>If the result is <code>#ok(miner_)</code>, it means the miner exists, and the miner's data is stored in the variable <code>miner</code>.</li></ul></li></ul></li><li><strong>Initialize Revenue History and Total Revenue</strong>:<ul><li>The function initializes <code>revenueHistory</code> as an empty array.</li><li>It initializes <code>totalRev</code> to 0, which will be used to accumulate the total revenue.</li></ul></li><li><strong>Get Revenue History</strong>:<ul><li>The function checks if there is revenue history for the miner using <code>revenueHash.get(Principal.toText(miner_.walletAddress))</code>.</li></ul></li><li><strong>Accumulate Revenue</strong>:<ul><li>If revenue history exists, the function updates <code>revenueHistory</code> and iterates over each entry in the revenue history:<ul><li>If the entry's <code>from</code> field is not &quot;adjustment&quot;, it adds the <code>sats</code> value to <code>totalRev</code>.</li></ul></li></ul></li><li><strong>Return Total Revenue</strong>:<ul><li>The function returns the accumulated total revenue <code>totalRev</code>.</li></ul></li></ol>

<p>In summary, the <code>getTotalRevenue</code> function calculates the total revenue of a specific miner by retrieving the miner's revenue history and accumulating the revenue while excluding adjustments.
It ensures that only admins can perform this operation and returns the total revenue as a <code>Nat</code> value.
If the miner does not exist or has no revenue history, it returns 0.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getAllRevenue"><code><span class="keyword">public func </span><span class="fnname">getAllRevenue</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p><p>The <code>getAllRevenue</code> function is a public shared asynchronous function that calculates and returns the total revenue of all miners, excluding adjustments. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns a <code>Nat</code> value representing the total revenue of all miners, excluding adjustments.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Retrieve User List</strong>:<ul><li>The function retrieves all entries from <code>usernameHash</code> and converts them to an array <code>ls</code>.</li></ul></li><li><strong>Initialize Total Revenue and Adjustment</strong>:<ul><li>The function initializes two variables:<ul><li><code>totalRev</code> to 0, which will be used to accumulate the total revenue.</li><li><code>adj</code> to 0, which will be used to accumulate the total adjustments.</li></ul></li></ul></li><li><strong>Loop Through Users</strong>:<ul><li>The function iterates over each user in <code>ls</code>.</li></ul></li><li><strong>Get Miner and Revenue History</strong>:<ul><li>For each user, the function retrieves the miner's data using <code>miners.get(usr.1)</code> and stores it in the variable <code>miner</code>.</li><li>It initializes <code>revenueHistory</code> as an empty array.</li><li>It checks if there is revenue history for the miner using <code>revenueHash.get(Principal.toText(miner_.walletAddress))</code>.</li></ul></li><li><strong>Accumulate Revenue and Adjustments</strong>:<ul><li>If revenue history exists, the function updates <code>revenueHistory</code> and iterates over each entry in the revenue history:<ul><li>If the entry's <code>from</code> field is &quot;adjustment&quot;, it adds the <code>sats</code> value to <code>adj</code>.</li><li>If the entry's <code>from</code> field is not &quot;adjustment&quot;, it adds the <code>sats</code> value to <code>totalRev</code>.</li></ul></li></ul></li><li><strong>Return Total Revenue</strong>:<ul><li>The function returns the total revenue excluding adjustments by subtracting <code>adj</code> from <code>totalRev</code>.</li></ul></li></ol>

<p>In summary, the <code>getAllRevenue</code> function calculates the total revenue of all miners by iterating through the list of users, retrieving each miner's revenue history, and accumulating the revenue while excluding adjustments.
It ensures that only admins can perform this operation and returns the total revenue as a <code>Nat</code> value.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getAllRevenueRaw"><code><span class="keyword">public func </span><span class="fnname">getAllRevenueRaw</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, [<a href="types.html#type.DistributionHistory"><span class="type">T.DistributionHistory</span></a>])]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getAllBalance"><code><span class="keyword">public func </span><span class="fnname">getAllBalance</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p><p>The <code>getAllBalance</code> function is a public shared asynchronous function that calculates and returns the total balance of all miners. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns a <code>Nat</code> value representing the total balance of all miners.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Retrieve User List</strong>:<ul><li>The function retrieves all entries from <code>usernameHash</code> and converts them to an array <code>ls</code>.</li></ul></li><li><strong>Initialize Total Revenue</strong>:<ul><li>The function initializes a variable <code>totalRev</code> to 0, which will be used to accumulate the total balance.</li></ul></li><li><strong>Loop Through Users</strong>:<ul><li>The function iterates over each user in <code>ls</code>.</li></ul></li><li><strong>Get Miner and Status</strong>:<ul><li>For each user, the function retrieves the miner's data using <code>miners.get(usr.1)</code> and stores it in the variable <code>miner</code>.</li><li>It retrieves the miner's status using <code>minerStatus.get(miner_.id)</code> and stores it in the variable <code>minerStat</code>.</li></ul></li><li><strong>Accumulate Balance</strong>:<ul><li>The function adds the miner's balance (<code>minerStat_.balance</code>) to <code>totalRev</code>.</li></ul></li><li><strong>Return Total Balance</strong>:<ul><li>The function returns the accumulated total balance <code>totalRev</code>.</li></ul></li></ol>

<p>In summary, the <code>getAllBalance</code> function calculates the total balance of all miners by iterating through the list of users, retrieving each miner's balance, and accumulating the balances.
It ensures that only admins can perform this operation and returns the total balance as a <code>Nat</code> value.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.withdrawCKBTC"><code><span class="keyword">public func </span><span class="fnname">withdrawCKBTC</span>(<br/>  <span class="parameter">username_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">amount_</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">address</span> : <span class="type">Text</span><br/>) : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>withdrawCKBTC</code> function is a public shared asynchronous function that handles the withdrawal of ckBTC for a miner. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes three parameters:<ul><li><code>username</code>: The username of the miner.</li><li><code>amount</code>: The amount of ckBTC to be withdrawn.</li><li><code>address</code>: The address to which the ckBTC will be sent.</li></ul></li><li>The function returns a <code>T.TransferRes</code> indicating the result of the withdrawal.</li></ul></li><li><strong>Pause Check</strong>:<ul><li>The function ensures that the system is not paused by calling <code>assert(_isNotPaused())</code>.</li></ul></li><li><strong>Balance Check</strong>:<ul><li>The function ensures that the total balance is greater than the amount to be withdrawn by calling <code>assert(totalBalance &gt; amount_)</code>.</li></ul></li><li><strong>Increment Withdrawal Index</strong>:<ul><li>The function increments the <code>withdrawalIndex</code> by 1.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(message.caller)</code> to retrieve the miner associated with the caller.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function does not proceed.</li><li>If the result is <code>#ok(m)</code>, it assigns the miner's ID to <code>id</code> and the miner's username to <code>uname</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>minerStatus</code>.</li></ul></li><li><strong>Check Sufficient Balance</strong>:<ul><li>The function checks if the miner has sufficient balance to cover the withdrawal amount plus a fee of 10 units.</li><li>If the balance is insufficient, it returns an error indicating the insufficient funds.</li></ul></li><li><strong>Log Pre-Transfer Transaction</strong>:<ul><li>The function logs the pre-transfer transaction by calling <code>logTransaction</code>.</li></ul></li><li><strong>Update Balances</strong>:<ul><li>The function updates the miner's balance, total withdrawn, and total shared revenue by subtracting the withdrawal amount plus the fee.</li><li>It also updates the <code>minerStatusAndRewardHash</code> with the new miner status.</li></ul></li><li><strong>Update Global Balances</strong>:<ul><li>The function updates the global <code>totalWithdrawn</code> and <code>totalBalance</code> by subtracting the withdrawal amount plus the fee.</li></ul></li><li><strong>Create Withdrawal History</strong>:<ul><li>The function creates a <code>T.WithdrawalHistory</code> record with the withdrawal details and stores it in the variable <code>wdh</code>.</li></ul></li><li><strong>Update Withdrawal Hash</strong>:<ul><li>The function updates the <code>withdrawalHash</code> and <code>allWithdrawalHash</code> with the new withdrawal history.</li></ul></li><li><strong>Perform Transfer</strong>:<ul><li>The function attempts to perform the ckBTC transfer using the <code>CKBTC.icrc1_transfer</code> method.</li><li>If an error occurs during the transfer, it reverts the balance updates, logs the failed transaction, and returns an error indicating the failure.</li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it logs the successful transaction, updates the <code>allSuccessfulWithdrawalHash</code>, and returns <code>#success(number)</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it reverts the balance updates, logs the failed transaction, and returns an error with the error message.</li></ul></li></ul></li></ol>

<p>In summary, the <code>withdrawCKBTC</code> function handles the withdrawal of ckBTC for a miner, ensuring that the system is not paused, the caller is verified, and the miner has sufficient balance.
It logs the transaction, updates the relevant balances, performs the ckBTC transfer, and handles various error cases.
If the withdrawal is successful, it logs the transaction and returns the success result.
If any errors occur, it reverts the balance updates and returns an error.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.whoCall"><code><span class="keyword">public func </span><span class="fnname">whoCall</span>() : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getTransaction"><code><span class="keyword">public func </span><span class="fnname">getTransaction</span>() : <span class="keyword">async </span>[<a href="types.html#type.TransactionHistory"><span class="type">T.TransactionHistory</span></a>]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.forcelogTransaction"><code><span class="keyword">public func </span><span class="fnname">forcelogTransaction</span>(<br/>  <span class="parameter">id_</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">action_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">amount_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">txid_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">currency_</span> : <span class="type">Text</span><br/>) : <span class="keyword">async </span>[<a href="types.html#type.TransactionHistory"><span class="type">T.TransactionHistory</span></a>]</code></h4><p><p>The <code>forcelogTransaction</code> function is a public shared asynchronous function that logs a transaction for a specific miner. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes five parameters:<ul><li><code>id</code>: The ID of the miner.</li><li><code>action</code>: The action associated with the transaction.</li><li><code>amount</code>: The amount involved in the transaction.</li><li><code>txid</code>: The transaction ID.</li><li><code>currency</code>: The currency involved in the transaction.</li></ul></li><li>The function returns an array of <code>T.TransactionHistory</code> asynchronously.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Create Transaction History</strong>:<ul><li>The function creates a <code>T.TransactionHistory</code> record with the following details:<ul><li><code>id</code>: The current value of <code>transactionIndex</code>.</li><li><code>time</code>: The current time obtained by calling <code>now()</code>.</li><li><code>action</code>: The action associated with the transaction (<code>action</code>).</li><li><code>amount</code>: The amount involved in the transaction (<code>amount</code>).</li><li><code>txid</code>: The transaction ID (<code>txid</code>).</li><li><code>currency</code>: The currency involved in the transaction (<code>currency</code>).</li></ul></li></ul></li><li><strong>Initialize Transaction Array</strong>:<ul><li>The function initializes an array <code>array</code> containing the created <code>transaction</code>.</li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus_.get(id_)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Update Miner Transactions</strong>:<ul><li>The function appends the created <code>transaction</code> to the miner's existing transactions using <code>Array.append</code>.</li></ul></li><li><strong>Add Transaction to Global List</strong>:<ul><li>The function adds the created <code>transaction</code> to the global <code>transactions</code> list.</li></ul></li><li><strong>Increment Transaction Index</strong>:<ul><li>The function increments the <code>transactionIndex</code> by 1 to ensure that the next transaction will have a unique ID.</li></ul></li><li><strong>Return Updated Transactions</strong>:<ul><li>The function returns the updated list of transactions for the miner.</li></ul></li></ol>

<p>In summary, the <code>forcelogTransaction</code> function logs a transaction for a specific miner by creating a transaction history record, updating the miner's transactions, and adding the transaction to the global list.
It ensures that only admins can perform this operation and returns the updated list of transactions for the miner.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.withdrawUSDT"><code><span class="keyword">public func </span><span class="fnname">withdrawUSDT</span>(<br/>  <span class="parameter">username_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">amount_</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">addr_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">usd_</span> : <span class="type">Text</span><br/>) : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>withdrawUSDT</code> function is a public shared asynchronous function that handles the withdrawal of USDT (Tether) for a miner. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes four parameters:<ul><li><code>username</code>: The username of the miner.</li><li><code>amount</code>: The amount of USDT to be withdrawn.</li><li><code>addr</code>: The address to which the USDT will be sent.</li><li><code>usd</code>: The amount of USDT in USD.</li></ul></li><li>The function returns a <code>T.TransferRes</code> indicating the result of the withdrawal.</li></ul></li><li><strong>Pause Check</strong>:<ul><li>The function ensures that the system is not paused by calling <code>assert(_isNotPaused())</code>.</li></ul></li><li><strong>Maintenance Check</strong>:<ul><li>The function immediately returns an error indicating that USDT withdrawals are temporarily unavailable due to maintenance.</li></ul></li><li><strong>Verify Caller</strong>:<ul><li>The function ensures that the caller is verified by calling <code>assert(_isVerified(message.caller))</code>.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(message.caller)</code> to retrieve the miner associated with the caller.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it returns an error indicating that the user does not exist.</li><li>If the result is <code>#ok(m)</code>, it assigns the miner's ID to <code>id</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>minerStatus</code>.</li></ul></li><li><strong>Check Sufficient Balance</strong>:<ul><li>The function checks if the miner has sufficient balance to cover the withdrawal amount plus a fee of 10 units.</li><li>If the balance is insufficient, it returns an error indicating the insufficient funds.</li></ul></li><li><strong>Log Pre-Transfer Transaction</strong>:<ul><li>The function logs the pre-transfer transaction by calling <code>logTransaction</code>.</li></ul></li><li><strong>Initialize HTTP Request</strong>:<ul><li>The function initializes an actor <code>ic</code> of type <code>T.IC</code> with the principal <code>&quot;aaaaa-aa&quot;</code>.</li><li>It constructs a unique ID <code>uid</code> and a URL for the HTTP request.</li></ul></li><li><strong>Update Balances</strong>:<ul><li>The function updates the miner's total withdrawn, total balance, and balance by subtracting the withdrawal amount plus the fee.</li><li>It also updates the miner's total shared revenue if applicable.</li></ul></li><li><strong>Update Miner Status Hash</strong>:<ul><li>The function updates the <code>minerStatusAndRewardHash</code> with the new miner status.</li></ul></li><li><strong>Send HTTP Request</strong>:<ul><li>The function sends the HTTP request by calling <code>send_http(url)</code> and awaits the response.</li><li>If an error occurs during the HTTP request, it reverts the balance updates and returns an error indicating the failure.</li></ul></li><li><strong>Check HTTP Response</strong>:<ul><li>The function checks if the HTTP response contains the text &quot;transfersuccess&quot;.</li><li>If the response is valid, it splits the response text and calls <code>moveCKBTC(amount_)</code> to transfer ckBTC.</li><li>If the ckBTC transfer fails, it reverts the balance updates, logs the failed transaction, and returns an error.</li></ul></li><li><strong>Log Successful Transaction</strong>:<ul><li>If the ckBTC transfer is successful, the function logs the successful transaction and returns <code>#success(amount_)</code>.</li></ul></li><li><strong>Handle Invalid HTTP Response</strong>:<ul><li>If the HTTP response is invalid, the function reverts the balance updates and returns an error with the response text.</li></ul></li></ol>

<p>In summary, the <code>withdrawUSDT</code> function handles the withdrawal of USDT for a miner, ensuring that the system is not paused, the caller is verified, and the miner has sufficient balance.
It logs the transaction, sends an HTTP request to process the withdrawal, and handles various error cases.
If the withdrawal is successful, it transfers ckBTC and logs the transaction.
If any errors occur, it reverts the balance updates and returns an error.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getUsername"><code><span class="keyword">public func </span><span class="fnname">getUsername</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <span class="type">Nat</span>)]</code></h4><p><p>The <code>getUsername</code> function is a public shared asynchronous function that retrieves all usernames and their corresponding IDs. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns an array of tuples <code>[(Text, Nat)]</code>, where each tuple contains a username and its corresponding ID.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Retrieve Usernames</strong>:<ul><li>The function retrieves all entries from <code>usernameHash</code>, which is a hash map storing usernames and their corresponding IDs.</li></ul></li><li><strong>Convert to Array</strong>:<ul><li>The function converts the entries from the hash map into an array using <code>Iter.toArray(usernameHash.entries())</code>.</li></ul></li><li><strong>Return Usernames</strong>:<ul><li>The function returns the array of usernames and their corresponding IDs.</li></ul></li></ol>

<p>In summary, the <code>getUsername</code> function retrieves all usernames and their corresponding IDs, ensuring that only admins can perform this operation.
It returns the data in an array of tuples format.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.shareRevenue"><code><span class="keyword">public func </span><span class="fnname">shareRevenue</span>(<span class="parameter">userName</span> : <span class="type">Text</span>, <span class="parameter">hashPercent_</span> : <span class="type">Nat</span>) : <span class="keyword">async </span>{#success : <span class="type">Nat</span>; #failed : <span class="type">Text</span>; #res : [(<span class="type">Text</span>, <a href="types.html#type.RevenueShare"><span class="type">T.RevenueShare</span></a>)]}</code></h4><p><p>Still building the workspace index, response may be less accurate.
The <code>shareRevenue</code> function in
main.mo
 is a public shared asynchronous function that allows a user to share a percentage of their revenue with another user. Here's a detailed description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes two parameters: <code>userName</code> of type <code>Text</code> and <code>hashPercent</code> of type <code>Nat</code>.</li><li>The function returns a variant type with two possible values: <code>#success : Nat</code> if the operation is successful, or <code>#failed : Text</code> if the operation fails.</li></ul></li><li><strong>Input Validation</strong>:<ul><li>The function checks if <code>hashPercent</code> is within the valid range (0, or between 100 and 10000). If not, it returns <code>#failed(&quot;Must 0, less than 100 and more than 1%&quot;)</code>.</li></ul></li><li><strong>Caller Verification</strong>:<ul><li>The function asserts that the caller's address is verified using the <code>_isAddressVerified</code> function.</li></ul></li><li><strong>Miner Existence Check</strong>:<ul><li>The function retrieves the miner associated with the caller using the <code>getMiner</code> function.</li><li>If the miner does not exist, it returns <code>#failed(&quot;user not exist&quot;)</code>.</li><li>If the miner exists, it assigns the miner's username to <code>callerName</code>.</li></ul></li><li><strong>Self-Share Check</strong>:<ul><li>The function checks if the caller is trying to share revenue with themselves. If so, it returns <code>#failed(&quot;share target cannot be yourself&quot;)</code>.</li></ul></li><li><strong>Target User Existence Check</strong>:<ul><li>The function checks if the target user exists in the <code>usernameHash</code>.</li><li>If the target user does not exist, it returns <code>#failed(&quot;target user not exist&quot;)</code>.</li></ul></li><li><strong>Revenue Sharing Logic</strong>:<ul><li>If the target user exists, the function retrieves the miner associated with the target user.</li><li>It creates a <code>share</code> object containing the target user's name, wallet address, and share percentage.</li></ul></li><li><strong>Existing Share Check</strong>:<ul><li>The function checks if the caller has already shared revenue with other users.</li><li>If so, it calculates the total shared percentage and ensures it does not exceed 100%.</li><li>It updates the <code>revenueShareHash</code> and <code>receivedRevenueShareHash</code> accordingly.</li></ul></li><li><strong>New Share Creation</strong>:<ul><li>If the caller has not shared revenue before, it creates a new <code>detailedHash</code> and updates the <code>revenueShareHash</code> and <code>receivedRevenueShareHash</code>.</li></ul></li><li><strong>Return Success</strong>:<ul><li>If all checks pass and the revenue share is successfully updated, the function returns <code>#success(hashPercent_)</code>.</li></ul></li></ol>

<p>The function ensures that revenue sharing is done correctly, with proper validation and checks to prevent errors and misuse.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getMinerData"><code><span class="keyword">public func </span><span class="fnname">getMinerData</span>() : <span class="keyword">async </span>{#none : <span class="type">Nat</span>; #ok : <a href="types.html#type.MinerData"><span class="type">T.MinerData</span></a>}</code></h4><p><p>The <code>getMinerData</code> function is a public query function that retrieves detailed information about the miner associated with the caller. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public query</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes no parameters.</li><li>The function returns a variant type with two possible values: <code>#none : Nat</code> if the miner is not found or not verified, or <code>#ok : T.MinerData</code> if the miner is found.</li></ul></li><li><strong>Verify Address</strong>:<ul><li>The function checks if the caller's address is verified by calling <code>_isAddressVerified(message.caller)</code>.</li><li>If the address is not verified, the function returns <code>#none(0)</code>.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(message.caller)</code> to retrieve the miner associated with the caller.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function returns <code>#none(1)</code>.</li><li>If the result is <code>#ok(m)</code>, it means the miner exists, and the miner's ID is stored in the variable <code>id</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Retrieve Revenue History</strong>:<ul><li>The function initializes <code>revenueHistory</code> as an empty array and <code>yesterdayRevenue</code> as 0.</li><li>It checks if there is revenue history for the miner using <code>revenueHash.get(Principal.toText(m.walletAddress))</code>.</li><li>If revenue history exists, it updates <code>revenueHistory</code> and sets <code>yesterdayRevenue</code> to the last entry's sats value.</li></ul></li><li><strong>Retrieve Current Shared Revenue</strong>:<ul><li>The function initializes <code>currentShared</code> as 0 and <code>shareList</code> as an empty list.</li><li>It checks if there are revenue sharing rules for the miner using <code>revenueShareHash.get(m.username)</code>.</li><li>If revenue sharing rules exist, it updates <code>currentShared</code> and <code>shareList</code> with the relevant data.</li></ul></li><li><strong>Retrieve Received Shared Revenue</strong>:<ul><li>The function initializes <code>receivedShareList</code> as an empty list.</li><li>It checks if there are received revenue sharing rules for the miner using <code>receivedRevenueShareHash.get(m.username)</code>.</li><li>If received revenue sharing rules exist, it updates <code>receivedShareList</code> with the relevant data.</li></ul></li><li><strong>Adjust Balance</strong>:<ul><li>The function adjusts the miner's balance by subtracting 10 if the balance is greater than 10. Otherwise, it sets the balance to 0.</li></ul></li><li><strong>Construct Miner Data</strong>:<ul><li>The function constructs a <code>T.MinerData</code> object with the retrieved and calculated data, including:<ul><li><code>id</code>, <code>walletAddress</code>, <code>walletAddressText</code>, <code>username</code>, <code>hashrate</code>, <code>verified</code>, <code>balance</code>, <code>totalWithdrawn</code>, <code>totalReceivedSharedRevenue</code>, <code>receivedShareList</code>, <code>savedWalletAddress</code>, <code>bankAddress</code>, <code>transactions</code>, <code>revenueHistory</code>, <code>yesterdayRevenue</code>, <code>totalSharedPercent</code>, and <code>shareList</code>.</li></ul></li></ul></li><li><strong>Return Miner Data</strong>:<ul><li>The function returns <code>#ok(minerData)</code> to indicate that the miner was found and includes the detailed miner data.</li></ul></li></ol>

<p>In summary, the <code>getMinerData</code> function retrieves detailed information about the miner associated with the caller, including their status, revenue history, shared revenue, and wallet addresses.
It ensures that the caller's address is verified and returns the miner's data in a structured format.
If the miner is not found or not verified, it returns <code>#none</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.fetchMinerByPrincipal"><code><span class="keyword">public func </span><span class="fnname">fetchMinerByPrincipal</span>(<span class="parameter">p</span> : <span class="type">Principal</span>) : <span class="keyword">async </span>{#none : <span class="type">Nat</span>; #ok : <a href="types.html#type.MinerData"><span class="type">T.MinerData</span></a>}</code></h4><p><p>The <code>fetchMinerByPrincipal</code> function is a public query function that retrieves detailed information about a miner based on their principal. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public query</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes a single parameter <code>p</code> of type <code>Principal</code>, which represents the principal of the miner.</li><li>The function returns a variant type with two possible values: <code>#none : Nat</code> if the miner is not found, or <code>#ok : T.MinerData</code> if the miner is found.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(p)</code> to retrieve the miner associated with the given principal.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function returns <code>#none(1)</code>.</li><li>If the result is <code>#ok(m)</code>, it means the miner exists, and the miner's ID is stored in the variable <code>id</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Retrieve Revenue History</strong>:<ul><li>The function initializes <code>revenueHistory</code> as an empty array and <code>yesterdayRevenue</code> as 0.</li><li>It checks if there is revenue history for the miner using <code>revenueHash.get(Principal.toText(m.walletAddress))</code>.</li><li>If revenue history exists, it updates <code>revenueHistory</code> and sets <code>yesterdayRevenue</code> to the last entry's sats value.</li></ul></li><li><strong>Retrieve Current Shared Revenue</strong>:<ul><li>The function initializes <code>currentShared</code> as 0 and <code>shareList</code> as an empty list.</li><li>It checks if there are revenue sharing rules for the miner using <code>revenueShareHash.get(m.username)</code>.</li><li>If revenue sharing rules exist, it updates <code>currentShared</code> and <code>shareList</code> with the relevant data.</li></ul></li><li><strong>Retrieve Received Shared Revenue</strong>:<ul><li>The function initializes <code>receivedShareList</code> as an empty list.</li><li>It checks if there are received revenue sharing rules for the miner using <code>receivedRevenueShareHash.get(m.username)</code>.</li><li>If received revenue sharing rules exist, it updates <code>receivedShareList</code> with the relevant data.</li></ul></li><li><strong>Construct Miner Data</strong>:<ul><li>The function constructs a <code>T.MinerData</code> object with the retrieved and calculated data, including:<ul><li><code>id</code>, <code>walletAddress</code>, <code>walletAddressText</code>, <code>username</code>, <code>hashrate</code>, <code>verified</code>, <code>balance</code>, <code>totalWithdrawn</code>, <code>totalReceivedSharedRevenue</code>, <code>receivedShareList</code>, <code>savedWalletAddress</code>, <code>bankAddress</code>, <code>transactions</code>, <code>revenueHistory</code>, <code>yesterdayRevenue</code>, <code>totalSharedPercent</code>, and <code>shareList</code>.</li></ul></li></ul></li><li><strong>Return Miner Data</strong>:<ul><li>The function returns <code>#ok(minerData)</code> to indicate that the miner was found and includes the detailed miner data.</li></ul></li></ol>

<p>In summary, the <code>fetchMinerByPrincipal</code> function retrieves detailed information about a miner, including their status, revenue history, shared revenue, and wallet addresses, based on the provided principal.
It ensures that the caller is an admin and returns the miner's data in a structured format.
If the miner is not found, it returns <code>#none</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.adjustB"><code><span class="keyword">public func </span><span class="fnname">adjustB</span>(<span class="parameter">uname</span> : <span class="type">Text</span>, <span class="parameter">bal</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p><p>The <code>adjustB</code> function is a public shared asynchronous function that adjusts the balance of a miner based on their username. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes two parameters:<ul><li><code>uname</code>: The username of the miner.</li><li><code>bal</code>: The new balance to be set for the miner.</li></ul></li><li>The function returns a <code>Nat</code> indicating the new balance.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Get Miner ID</strong>:<ul><li>The function initializes <code>p</code> to 0.</li><li>It retrieves the miner's ID using <code>usernameHash.get(uname)</code> and stores it in <code>p</code>.</li></ul></li><li><strong>Get Miner and Status</strong>:<ul><li>The function retrieves the miner's data using <code>miners.get(p)</code> and stores it in the variable <code>miner</code>.</li><li>It retrieves the miner's status using <code>minerStatus.get(miner_.id)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Update Miner Balance</strong>:<ul><li>The function updates the miner's balance to the new value <code>bal</code> by setting <code>status_.balance := bal</code>.</li></ul></li><li><strong>Return New Balance</strong>:<ul><li>The function returns the new balance <code>bal</code> to indicate that the adjustment was successful.</li></ul></li></ol>

<p>In summary, the <code>adjustB</code> function updates the balance of a miner based on their username, ensuring that the caller is an admin and that the miner exists.
It retrieves the miner's data and status, updates the balance, and returns the new balance.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.adjustMiner"><code><span class="keyword">public func </span><span class="fnname">adjustMiner</span>(<br/>  <span class="parameter">uname</span> : <span class="type">Text</span>, <br/>  <span class="parameter">newUname</span> : <span class="type">Text</span>, <br/>  <span class="parameter">balance</span> : <span class="type">Nat</span><br/>) : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p><p>The <code>adjustMiner</code> function is a public shared asynchronous function that adjusts the username and balance of a miner. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes three parameters:<ul><li><code>uname</code>: The current username of the miner.</li><li><code>newUname</code>: The new username to be assigned to the miner.</li><li><code>balance</code>: The new balance to be set for the miner.</li></ul></li><li>The function returns a <code>Nat</code> indicating the result of the adjustment (1 for success, 0 for failure).</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Get Miner ID</strong>:<ul><li>The function initializes <code>p</code> to 0.</li><li>It retrieves the miner's ID using <code>usernameHash.get(uname)</code> and stores it in <code>p</code>.</li><li>If the username is found, it deletes the old username from <code>usernameHash</code> and adds the new username with the same ID.</li><li>If the username is not found, it returns 0 to indicate failure.</li></ul></li><li><strong>Get Miner and Update Username</strong>:<ul><li>The function retrieves the miner's data using <code>miners.get(p)</code> and stores it in the variable <code>miner</code>.</li><li>It updates the miner's username to <code>newUname</code>.</li></ul></li><li><strong>Update Miner Balance</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(miner_.id)</code> and stores it in the variable <code>status</code>.</li><li>It updates the miner's balance to the new value <code>balance</code>.</li></ul></li><li><strong>Return Success</strong>:<ul><li>The function returns 1 to indicate that the adjustment was successful.</li></ul></li></ol>

<p>In summary, the <code>adjustMiner</code> function updates the username and balance of a miner, ensuring that the caller is an admin and that the miner exists.
If the miner is found and updated successfully, it returns 1; otherwise, it returns 0.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.backupUserData"><code><span class="keyword">public func </span><span class="fnname">backupUserData</span>() : <span class="keyword">async </span>[<a href="types.html#type.MinerData"><span class="type">T.MinerData</span></a>]</code></h4><p><p>The <code>backupUserData</code> function is a public shared asynchronous function that creates a backup of all user data. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns an array of <code>T.MinerData</code> asynchronously.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Initialize Result Array</strong>:<ul><li>The function initializes an empty array <code>res</code> of type <code>[T.MinerData]</code> to store the backup data.</li></ul></li><li><strong>Retrieve User List</strong>:<ul><li>The function retrieves all entries from <code>usernameHash</code> and converts them to an array <code>listUser</code>.</li></ul></li><li><strong>Loop Through Users</strong>:<ul><li>The function iterates over each user in <code>listUser</code>.</li></ul></li><li><strong>Get Miner and Status</strong>:<ul><li>For each user, the function retrieves the miner's data using <code>miners.get(usr.1)</code> and stores it in the variable <code>miner</code>.</li><li>It retrieves the miner's status using <code>minerStatus.get(miner_.id)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Retrieve Revenue History</strong>:<ul><li>The function initializes <code>revenueHistory</code> as an empty array and <code>yesterdayRevenue</code> as 0.</li><li>It checks if there is revenue history for the miner using <code>revenueHash.get(Principal.toText(miner_.walletAddress))</code>.</li><li>If revenue history exists, it updates <code>revenueHistory</code> and sets <code>yesterdayRevenue</code> to the last entry's sats value.</li></ul></li><li><strong>Retrieve Current Shared Revenue</strong>:<ul><li>The function initializes <code>currentShared</code> as 0 and <code>shareList</code> as an empty list.</li><li>It checks if there are revenue sharing rules for the miner using <code>revenueShareHash.get(miner_.username)</code>.</li><li>If revenue sharing rules exist, it updates <code>currentShared</code> and <code>shareList</code> with the relevant data.</li></ul></li><li><strong>Retrieve Received Shared Revenue</strong>:<ul><li>The function initializes <code>receivedShareList</code> as an empty list.</li><li>It checks if there are received revenue sharing rules for the miner using <code>receivedRevenueShareHash.get(miner_.username)</code>.</li><li>If received revenue sharing rules exist, it updates <code>receivedShareList</code> with the relevant data.</li></ul></li><li><strong>Construct Miner Data</strong>:<ul><li>The function constructs a <code>T.MinerData</code> object with the retrieved and calculated data, including:<ul><li><code>id</code>, <code>walletAddress</code>, <code>walletAddressText</code>, <code>username</code>, <code>hashrate</code>, <code>verified</code>, <code>balance</code>, <code>totalWithdrawn</code>, <code>totalReceivedSharedRevenue</code>, <code>receivedShareList</code>, <code>savedWalletAddress</code>, <code>bankAddress</code>, <code>transactions</code>, <code>revenueHistory</code>, <code>yesterdayRevenue</code>, <code>totalSharedPercent</code>, and <code>shareList</code>.</li></ul></li></ul></li><li><strong>Append Miner Data to Result Array</strong>:<ul><li>The function appends the constructed <code>T.MinerData</code> object to the <code>res</code> array.</li></ul></li><li><strong>Return Result</strong>:<ul><li>The function returns the <code>res</code> array containing the backup data for all users.
In summary, the <code>backupUserData</code> function creates a backup of all user data by retrieving and compiling detailed information about each miner, including their status, revenue history, shared revenue, and wallet addresses. It ensures that only admins can perform the backup and returns the compiled data in a structured format.</li></ul></li></ol></p></div><div class="declaration"><h4 class="function" id="Miner.adjustMinerBalance"><code><span class="keyword">public func </span><span class="fnname">adjustMinerBalance</span>(<span class="parameter">queries</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p><p>The <code>adjustMinerBalance</code> function is a public shared asynchronous function that adjusts the balance of miners based on a set of queries. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>queries</code> of type <code>Text</code>, which contains the adjustment queries.</li><li>The function returns a <code>Text</code> indicating the result of the adjustments.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Split Queries</strong>:<ul><li>The function splits the <code>queries</code> string into individual queries using the <code>textSplit</code> function with the delimiter <code>|</code>.</li><li>It initializes <code>totalString</code> and <code>unameString</code> as empty strings to accumulate results.</li></ul></li><li><strong>Loop Through Queries</strong>:<ul><li>The function iterates over each query in <code>datas</code>.</li></ul></li><li><strong>Process Each Query</strong>:<ul><li>For each query, it splits the query into <code>uname</code> (username) and <code>reward</code> (adjustment amount) using the <code>textSplit</code> function with the delimiter <code>/</code>.</li><li>It converts the <code>reward</code> string to a <code>Nat</code> using the <code>textToNat</code> function.</li><li>It retrieves the miner's ID using <code>usernameHash.get(uname)</code> and stores it in <code>p</code>.</li></ul></li><li><strong>Get Miner and Status</strong>:<ul><li>The function retrieves the miner's data using <code>miners.get(p)</code> and stores it in <code>miner</code>.</li><li>It initializes <code>totalShared</code> to 0.</li></ul></li><li><strong>Handle Revenue Sharing</strong>:<ul><li>The function checks if there are revenue sharing rules for the miner using <code>revenueShareHash.get(uname)</code>.</li><li>If revenue sharing rules exist, it iterates over the shared targets and adjusts their balances and total shared revenue.</li><li>It updates the <code>revenueHash</code> with the shared rewards and logs the adjustments.</li></ul></li><li><strong>Update Miner Revenue</strong>:<ul><li>The function creates a <code>T.DistributionHistory</code> record for the miner with the adjusted reward.</li><li>It updates the <code>revenueHash</code> with the new revenue record.</li></ul></li><li><strong>Update Miner Status</strong>:<ul><li>The function updates the miner's balance by subtracting the adjusted reward.</li><li>It updates the <code>minerStatusAndRewardHash</code> with the new balance and transactions.</li></ul></li><li><strong>Update Total Balance</strong>:<ul><li>The function updates the <code>totalBalance</code> by subtracting the reward.</li></ul></li><li><strong>Return Result</strong>:<ul><li>The function accumulates the results in <code>unameString</code> and <code>totalString</code>.</li><li>It returns <code>unameString</code> as the result of the adjustments.</li></ul></li></ol>

<p>In summary, the <code>adjustMinerBalance</code> function processes a set of queries to adjust the balances of miners, handles revenue sharing, updates the relevant records, and returns the result of the adjustments.
It ensures that only admins can perform the adjustments and logs the changes appropriately.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.fetchMinerByUsername"><code><span class="keyword">public func </span><span class="fnname">fetchMinerByUsername</span>(<span class="parameter">uname</span> : <span class="type">Text</span>) : <span class="keyword">async </span>{#none : <span class="type">Nat</span>; #ok : <a href="types.html#type.MinerData"><span class="type">T.MinerData</span></a>}</code></h4><p><p>The <code>fetchMinerByUsername</code> function is a public query function that retrieves detailed information about a miner based on their username. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public query</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes a single parameter <code>uname</code> of type <code>Text</code>, which represents the username of the miner.</li><li>The function returns a variant type with two possible values: <code>#none : Nat</code> if the miner is not found, or <code>#ok : T.MinerData</code> if the miner is found.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Initialize Variables</strong>:<ul><li>The function initializes <code>yesterdayRevenue</code> to 0 and <code>p</code> to 0.</li></ul></li><li><strong>Get Miner ID</strong>:<ul><li>The function retrieves the miner's ID using <code>usernameHash.get(uname)</code> and stores it in the variable <code>p</code>.</li><li>If the username is not found, <code>p</code> remains 0.</li></ul></li><li><strong>Get Miner and Status</strong>:<ul><li>The function retrieves the miner's data using <code>miners.get(p)</code> and stores it in the variable <code>miner</code>.</li><li>It retrieves the miner's status using <code>minerStatus.get(miner_.id)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Retrieve Revenue History</strong>:<ul><li>The function initializes <code>revenueHistory</code> as an empty array.</li><li>It checks if there is revenue history for the miner using <code>revenueHash.get(Principal.toText(miner_.walletAddress))</code>.</li><li>If revenue history exists, it updates <code>revenueHistory</code> and sets <code>yesterdayRevenue</code> to the last entry's sats value.</li></ul></li><li><strong>Retrieve Current Shared Revenue</strong>:<ul><li>The function initializes <code>currentShared</code> as 0 and <code>shareList</code> as an empty list.</li><li>It checks if there are revenue sharing rules for the miner using <code>revenueShareHash.get(miner_.username)</code>.</li><li>If revenue sharing rules exist, it updates <code>currentShared</code> and <code>shareList</code> with the relevant data.</li></ul></li><li><strong>Retrieve Received Shared Revenue</strong>:<ul><li>The function initializes <code>receivedShareList</code> as an empty list.</li><li>It checks if there are received revenue sharing rules for the miner using <code>receivedRevenueShareHash.get(miner_.username)</code>.</li><li>If received revenue sharing rules exist, it updates <code>receivedShareList</code> with the relevant data.</li></ul></li><li><strong>Construct Miner Data</strong>:<ul><li>The function constructs a <code>T.MinerData</code> object with the retrieved and calculated data, including:<ul><li><code>id</code>, <code>walletAddress</code>, <code>walletAddressText</code>, <code>username</code>, <code>hashrate</code>, <code>verified</code>, <code>balance</code>, <code>totalWithdrawn</code>, <code>totalReceivedSharedRevenue</code>, <code>receivedShareList</code>, <code>savedWalletAddress</code>, <code>bankAddress</code>, <code>transactions</code>, <code>revenueHistory</code>, <code>yesterdayRevenue</code>, <code>totalSharedPercent</code>, and <code>shareList</code>.</li></ul></li></ul></li><li><strong>Return Miner Data</strong>:<ul><li>The function returns <code>#ok(minerData)</code> to indicate that the miner was found and includes the detailed miner data.</li></ul></li></ol>

<p>In summary, the <code>fetchMinerByUsername</code> function retrieves detailed information about a miner, including their status, revenue history, shared revenue, and wallet addresses, based on the provided username.
It ensures that the caller is an admin and returns the miner's data in a structured format.
If the miner is not found, it returns <code>#none</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.fetchMinerById"><code><span class="keyword">public func </span><span class="fnname">fetchMinerById</span>(<span class="parameter">p</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><a href="types.html#type.MinerData"><span class="type">T.MinerData</span></a></code></h4><p><p>The <code>fetchMinerById</code> function is a public query function that retrieves detailed information about a miner based on their ID. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public query</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes a single parameter <code>p</code> of type <code>Nat</code> (natural number), which represents the ID of the miner.</li><li>The function returns a <code>T.MinerData</code> object asynchronously.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Get Miner and Status</strong>:<ul><li>The function retrieves the miner's data using <code>miners.get(p)</code> and stores it in the variable <code>miner</code>.</li><li>It retrieves the miner's status using <code>minerStatus.get(miner_.id)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Retrieve Revenue History</strong>:<ul><li>The function initializes <code>revenueHistory</code> as an empty array and <code>yesterdayRevenue</code> as 0.</li><li>It checks if there is revenue history for the miner using <code>revenueHash.get(Principal.toText(miner_.walletAddress))</code>.</li><li>If revenue history exists, it updates <code>revenueHistory</code> and sets <code>yesterdayRevenue</code> to the last entry's sats value.</li></ul></li><li><strong>Retrieve Current Shared Revenue</strong>:<ul><li>The function initializes <code>currentShared</code> as 0 and <code>shareList</code> as an empty list.</li><li>It checks if there are revenue sharing rules for the miner using <code>revenueShareHash.get(miner_.username)</code>.</li><li>If revenue sharing rules exist, it updates <code>currentShared</code> and <code>shareList</code> with the relevant data.</li></ul></li><li><strong>Retrieve Received Shared Revenue</strong>:<ul><li>The function initializes <code>receivedShareList</code> as an empty list.</li><li>It checks if there are received revenue sharing rules for the miner using <code>receivedRevenueShareHash.get(miner_.username)</code>.</li><li>If received revenue sharing rules exist, it updates <code>receivedShareList</code> with the relevant data.</li></ul></li><li><strong>Construct Miner Data</strong>:<ul><li>The function constructs a <code>T.MinerData</code> object with the retrieved and calculated data, including:<ul><li><code>id</code>, <code>walletAddress</code>, <code>walletAddressText</code>, <code>username</code>, <code>hashrate</code>, <code>verified</code>, <code>balance</code>, <code>totalWithdrawn</code>, <code>totalReceivedSharedRevenue</code>, <code>receivedShareList</code>, <code>savedWalletAddress</code>, <code>bankAddress</code>, <code>transactions</code>, <code>revenueHistory</code>, <code>yesterdayRevenue</code>, <code>totalSharedPercent</code>, and <code>shareList</code>.</li></ul></li></ul></li><li><strong>Return Miner Data</strong>:<ul><li>The function returns the constructed <code>T.MinerData</code> object.</li></ul></li></ol>

<p>In summary, the <code>fetchMinerById</code> function retrieves detailed information about a miner, including their status, revenue history, shared revenue, and wallet addresses, based on the provided miner ID.
It ensures that the caller is an admin and returns the miner's data in a structured format.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getWallets"><code><span class="keyword">public func </span><span class="fnname">getWallets</span>(<span class="parameter">id_</span> : <span class="type">Nat</span>) : <span class="keyword">async </span>[<a href="types.html#type.WalletAddress"><span class="type">T.WalletAddress</span></a>]</code></h4><p><p>The <code>getWallets</code> function is a public query function that retrieves the wallet addresses associated with a specific miner. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public query</code>, meaning it can be called by external actors and does not modify the state.</li><li>It takes a single parameter <code>id</code> of type <code>Nat</code> (natural number), which represents the ID of the miner.</li><li>The function returns an array of <code>T.WalletAddress</code> asynchronously.</li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>miner</code>.</li></ul></li><li><strong>Return Wallet Addresses</strong>:<ul><li>The function returns the <code>walletAddress</code> field from the miner's status, which is an array of <code>T.WalletAddress</code>.</li></ul></li></ol>

<p>In summary, the <code>getWallets</code> function retrieves and returns the wallet addresses associated with a specific miner based on the provided miner ID.
It ensures that the function is a query, meaning it does not modify the state and can be called by external actors.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.saveWalletAddress"><code><span class="keyword">public func </span><span class="fnname">saveWalletAddress</span>(<br/>  <span class="parameter">name_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">address_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">currency_</span> : <span class="type">Text</span><br/>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p><p>The <code>saveWalletAddress</code> function is a public shared asynchronous function that saves a wallet address for the miner associated with the caller. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes three parameters:<ul><li><code>name</code>: The name associated with the wallet address.</li><li><code>address</code>: The wallet address.</li><li><code>currency</code>: The currency associated with the wallet address.</li></ul></li><li>The function returns a <code>Bool</code> indicating success (<code>true</code>) or failure (<code>false</code>).</li></ul></li><li><strong>Verify Address</strong>:<ul><li>The function ensures that the caller's address is verified by calling <code>assert(_isAddressVerified(message.caller))</code>.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(message.caller)</code> to retrieve the miner associated with the caller.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function returns <code>false</code>.</li><li>If the result is <code>#ok(m)</code>, it means the miner exists, and the miner's ID is stored in the variable <code>id</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Check for Existing Wallet Address</strong>:<ul><li>The function checks if the wallet address already exists in the miner's wallet addresses using <code>Array.find</code>.</li><li>If the wallet address is found, the function asserts <code>isthere == null</code> to ensure it does not already exist.</li></ul></li><li><strong>Create Wallet Address</strong>:<ul><li>The function creates a new wallet address record with the provided details and stores it in the variable <code>wallet</code>.</li></ul></li><li><strong>Append Wallet Address</strong>:<ul><li>The function appends the new wallet address to the miner's existing wallet addresses using <code>Array.append</code>.</li></ul></li><li><strong>Return Success</strong>:<ul><li>The function returns <code>true</code> to indicate that the wallet address was successfully saved.</li></ul></li></ol>

<p>In summary, the <code>saveWalletAddress</code> function saves a new wallet address for the miner associated with the caller, ensuring that the caller's address is verified and that the wallet address does not already exist.
If the miner does not exist, it returns <code>false</code>; otherwise, it saves the wallet address and returns <code>true</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.saveBankAddress"><code><span class="keyword">public func </span><span class="fnname">saveBankAddress</span>(<br/>  <span class="parameter">name_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">account_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">bankName_</span> : <span class="type">Text</span>, <br/>  <span class="parameter">jwalletId_</span> : <span class="type">Text</span><br/>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p><p>The <code>saveBankAddress</code> function is a public shared asynchronous function that saves a bank address for the miner associated with the caller. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes four parameters:<ul><li><code>name</code>: The name associated with the bank account.</li><li><code>account</code>: The bank account number.</li><li><code>bankName</code>: The name of the bank.</li><li><code>jwalletId</code>: The jwallet ID associated with the bank account.</li></ul></li><li>The function returns a <code>Bool</code> indicating success (<code>true</code>) or failure (<code>false</code>).</li></ul></li><li><strong>Verify Address</strong>:<ul><li>The function ensures that the caller's address is verified by calling <code>assert(_isAddressVerified(message.caller))</code>.</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(message.caller)</code> to retrieve the miner associated with the caller.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function returns <code>false</code>.</li><li>If the result is <code>#ok(m)</code>, it means the miner exists, and the miner's ID is stored in the variable <code>id</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>status</code>.</li></ul></li><li><strong>Check for Existing Bank Account</strong>:<ul><li>The function checks if the bank account already exists in the miner's bank addresses using <code>Array.find</code>.</li><li>If the bank account is found, the function asserts <code>isthere == null</code> to ensure it does not already exist.</li></ul></li><li><strong>Create Bank Address</strong>:<ul><li>The function creates a new bank address record with the provided details and stores it in the variable <code>bank</code>.</li></ul></li><li><strong>Append Bank Address</strong>:<ul><li>The function appends the new bank address to the miner's existing bank addresses using <code>Array.append</code>.</li></ul></li><li><strong>Return Success</strong>:<ul><li>The function returns <code>true</code> to indicate that the bank address was successfully saved.</li></ul></li></ol>

<p>In summary, the <code>saveBankAddress</code> function saves a new bank address for the miner associated with the caller, ensuring that the caller's address is verified and that the bank account does not already exist.
If the miner does not exist, it returns <code>false</code>; otherwise, it saves the bank address and returns <code>true</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.setBalance"><code><span class="keyword">public func </span><span class="fnname">setBalance</span>(<span class="parameter">b</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p><p>The <code>setBalance</code> function is a public shared asynchronous function that sets the balance for the miner associated with the caller. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>b</code> of type <code>Nat</code> (natural number) which represents the new balance to be set.</li><li>The function returns a <code>Bool</code> indicating success (<code>true</code>) or failure (<code>false</code>).</li></ul></li><li><strong>Get Miner</strong>:<ul><li>The function calls <code>getMiner(message.caller)</code> to retrieve the miner associated with the caller.</li><li>The result is stored in the variable <code>res</code>.</li></ul></li><li><strong>Check Miner Existence</strong>:<ul><li>The function uses a <code>switch</code> statement to check if the miner exists:<ul><li>If the result is <code>#none</code>, it means the miner does not exist, and the function returns <code>false</code>.</li><li>If the result is <code>#ok(m)</code>, it means the miner exists, and the miner's ID is stored in the variable <code>id</code>.</li></ul></li></ul></li><li><strong>Get Miner Status</strong>:<ul><li>The function retrieves the miner's status using <code>minerStatus.get(id_)</code> and stores it in the variable <code>minerStatus</code>.</li></ul></li><li><strong>Set Balance</strong>:<ul><li>The function sets the miner's balance to the new value <code>b</code> by updating <code>minerStatus_.balance</code>.</li></ul></li><li><strong>Return Success</strong>:<ul><li>The function returns <code>true</code> to indicate that the balance was successfully set.</li></ul></li></ol>

<p>In summary, the <code>setBalance</code> function updates the balance of the miner associated with the caller, ensuring that the miner exists before performing the update.
If the miner does not exist, it returns <code>false</code>; otherwise, it sets the balance and returns <code>true</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.routine24Force"><code><span class="keyword">public func </span><span class="fnname">routine24Force</span>() : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.specialReward"><code><span class="keyword">public func </span><span class="fnname">specialReward</span>(<span class="parameter">hashrateData</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p><p>The <code>specialReward</code> function is responsible for distributing special rewards based on provided hashrate data. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>hashrateData</code> of type <code>Text</code>.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Set Distribution Status</strong>:<ul><li>The function sets the <code>distributionStatus</code> to &quot;processing&quot; to indicate that the distribution process is ongoing.</li></ul></li><li><strong>Get Current Time</strong>:<ul><li>The function retrieves the current time using <code>now()</code> and stores it in the variable <code>now</code>.</li></ul></li><li><strong>Initialize Variables</strong>:<ul><li>The function initializes <code>hashrateRewards</code> with the provided <code>hashrateData</code>.</li><li>It also initializes a counter variable <code>count</code> to 0.</li></ul></li><li><strong>Log Distribution</strong>:<ul><li>The function logs the distribution process by calling <code>logDistribution</code> with appropriate parameters.</li></ul></li><li><strong>Distribute Special Reward</strong>:<ul><li>The function calls <code>distributeSpecialReward</code> with <code>hashrateRewards</code> and awaits its result, storing the result in the variable <code>a</code>.</li></ul></li><li><strong>Return Result</strong>:<ul><li>The function returns a concatenated string of <code>hashrateRewards</code> and the result <code>a</code>.</li></ul></li></ol>

<p>The function ensures that only admins can initiate the special reward distribution, logs the distribution process, and calls another function to handle the actual distribution of rewards based on the provided hashrate data.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.distributeMiningRewards"><code><span class="keyword">public func </span><span class="fnname">distributeMiningRewards</span>(<span class="parameter">rewards_</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.distributeSpecialReward"><code><span class="keyword">public func </span><span class="fnname">distributeSpecialReward</span>(<span class="parameter">rewards_</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setT"><code><span class="keyword">public func </span><span class="fnname">setT</span>(<span class="parameter">a</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.verifyMiner"><code><span class="keyword">public func </span><span class="fnname">verifyMiner</span>(<span class="parameter">uname__</span> : <span class="type">Text</span>, <span class="parameter">hash_</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.addTestUser"><code><span class="keyword">public func </span><span class="fnname">addTestUser</span>() : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.transform"><code><span class="keyword">public func </span><span class="fnname">transform</span>(<span class="parameter">raw</span> : <a href="types.html#type.TransformArgs"><span class="type">T.TransformArgs</span></a>) : <span class="keyword">async </span><a href="types.html#type.CanisterHttpResponsePayload"><span class="type">T.CanisterHttpResponsePayload</span></a></code></h4><p></p></div><p></p></div></div></body></html>