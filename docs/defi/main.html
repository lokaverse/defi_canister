<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="../styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="../Token.html">Token</a></li></li><li><li><a href="../ckbtctest/main.html">ckbtctest/main</a></li></li><li><li><a href="../defi/main.html">defi/main</a></li></li><li><li><a href="../defi/types.html">defi/types</a></li></li><li><li><a href="../lokbtc/main.html">lokbtc/main</a></li></li><li><li><a href="../pool/main.html">pool/main</a></li></li><li><li><a href="../pool/types.html">pool/types</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Miner">Miner</a></li></li></ul></nav><div class="documentation"><h1>defi/main</h1><div class="declaration"><h4 class="class-declaration" id="type.Miner"><span class="keyword">actor </span><span class="keyword">class </span><span class="classname">Miner</span>()</h4><div class="declaration"><h4 class="function" id="Miner.clearDefiData"><code><span class="keyword">public func </span><span class="fnname">clearDefiData</span>(<span class="parameter">burn</span> : <span class="type">Bool</span>) : <span class="keyword">async </span>()</code></h4><p><p>The <code>clearDefiData</code> function is a public shared asynchronous function that clears all DeFi-related data and optionally burns test ckBTC. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>burn</code> of type <code>Bool</code>, which indicates whether to burn test ckBTC.</li><li>The function returns <code>async ()</code>, indicating it performs asynchronous operations and returns no value.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Clear Hash Maps</strong>:<ul><li>The function clears various hash maps related to DeFi data by reinitializing them with empty hash maps:<ul><li><code>addLiquidityHash</code></li><li><code>sharesHash</code></li><li><code>transactionHash</code></li><li><code>withdrawalHash</code></li><li><code>userLiquidityHash</code></li><li><code>userWithdrawalHash</code></li><li><code>userAddressHash</code></li><li><code>userIdHash</code></li><li><code>userClaimableCKBTCHash</code></li><li><code>userClaimableMPTSHash</code></li><li><code>userClaimableLPTSHash</code></li><li><code>userMaturedClaimableCKBTCHash</code></li></ul></li></ul></li><li><strong>Burn Test ckBTC (Optional)</strong>:<ul><li>If the <code>burn</code> parameter is <code>true</code>, the function calls <code>burnTestCKBTC()</code> and awaits its result.</li></ul></li><li><strong>Force Rebase</strong>:<ul><li>The function calls <code>LOKBTC.forceRebase()</code> and awaits its result.</li></ul></li><li><strong>Reset Variables</strong>:<ul><li>The function resets various variables related to DeFi data:<ul><li><code>totalShares</code> to 0</li><li><code>usersIndex</code> to 0</li><li><code>transactionIndex</code> to 0</li><li><code>pause</code> to <code>false</code></li><li><code>rebaseIndex</code> to 0</li><li><code>liquidityIndex</code> to 0</li><li><code>schedulerId</code> to 0</li><li><code>nextTimeStamp</code> to 0</li><li><code>counter</code> to 0</li></ul></li></ul></li></ol>

<p>In summary, the <code>clearDefiData</code> function clears all DeFi-related data by reinitializing various hash maps and resetting related variables. It ensures that only admins can perform this operation. Optionally, it burns test ckBTC if the <code>burn</code> parameter is <code>true</code>, and it forces a rebase of LOKBTC.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getCurrentScheduler"><code><span class="keyword">public func </span><span class="fnname">getCurrentScheduler</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getNextRebaseHour"><code><span class="keyword">public func </span><span class="fnname">getNextRebaseHour</span>() : <span class="keyword">async </span><span class="type">Int</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getUserData"><code><span class="keyword">public func </span><span class="fnname">getUserData</span>() : <span class="keyword">async </span>{ ckbtc : <span class="type">Nat</span>; lokbtc : <span class="type">Nat</span>; staked : <span class="type">Nat</span>; mpts : <span class="type">Nat</span>; lpts : <span class="type">Nat</span>; claimableMPTS : <span class="type">Nat</span>; claimableLPTS : <span class="type">Nat</span>; ckBTCClaimList : [(<span class="type">Nat</span>, <a href="types.html#type.Claimable"><span class="type">T.Claimable</span></a>)]; totalWithdrawableCKBTC : <span class="type">Nat</span>; totalPendingCKBTC : <span class="type">Nat</span> }</code></h4><p><p>The <code>getUserData</code> function is a public shared asynchronous function that retrieves various balances and claimable amounts for the caller. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns an object with multiple fields representing the user's data.</li></ul></li><li><strong>Retrieve Balances</strong>:<ul><li>The function retrieves the current balances of ckBTC, lokBTC, MPTS, and LPTS for the caller using the <code>icrc1_balance_of</code> method for each token.</li><li>The balances are stored in the variables <code>ckBTCBalance</code>, <code>lokBTCBalance</code>, <code>mptsBalance</code>, and <code>lptsBalance</code>.</li></ul></li><li><strong>Initialize Variables</strong>:<ul><li>The function initializes several variables to store the user's data:<ul><li><code>stakedShare</code> to 0.</li><li><code>claimList</code> to an empty list.</li><li><code>claimableLPTS_</code> to 0.</li><li><code>claimableMPTS_</code> to 0.</li><li><code>now_</code> to the current time in milliseconds.</li><li><code>totalWithdrawableCKBTC</code> to 0.</li><li><code>totalPendingCKBTC</code> to 0.</li><li><code>callertxt</code> to the text representation of the caller's principal.</li></ul></li></ul></li><li><strong>Retrieve Withdrawable ckBTC</strong>:<ul><li>The function checks if there are any matured claimable ckBTC for the caller in <code>userMaturedClaimableCKBTCHash</code>.</li><li>If found, it adds the amount to <code>totalWithdrawableCKBTC</code>.</li></ul></li><li><strong>Retrieve Claimable ckBTC</strong>:<ul><li>The function checks if there are any claimable ckBTC for the caller in <code>userClaimableCKBTCHash</code>.</li><li>If found, it iterates over the claimable entries:<ul><li>If the claim is matured (time &lt;= now_), it adds the amount to <code>totalWithdrawableCKBTC</code> and removes the entry from the hash map.</li><li>If the claim is not matured, it adds the amount to <code>totalPendingCKBTC</code>.</li></ul></li><li>It updates the <code>userClaimableCKBTCHash</code> and <code>userMaturedClaimableCKBTCHash</code> with the new values.</li></ul></li><li><strong>Retrieve Claimable LPTS and MPTS</strong>:<ul><li>The function checks if there are any claimable LPTS and MPTS for the caller in <code>userClaimableLPTSHash</code> and <code>userClaimableMPTSHash</code>.</li><li>If found, it updates <code>claimableLPTS_</code> and <code>claimableMPTS_</code> with the respective amounts.</li></ul></li><li><strong>Retrieve Staked Shares</strong>:<ul><li>The function checks if there are any staked shares for the caller in <code>sharesHash</code>.</li><li>If found, it updates <code>stakedShare</code> with the share amount.</li></ul></li><li><strong>Return User Data</strong>:<ul><li>The function constructs an object <code>datas</code> with the retrieved and calculated data, including:<ul><li><code>ckbtc</code>: The ckBTC balance.</li><li><code>lokbtc</code>: The lokBTC balance.</li><li><code>staked</code>: The staked share amount.</li><li><code>lpts</code>: The LPTS balance.</li><li><code>mpts</code>: The MPTS balance.</li><li><code>ckBTCClaimList</code>: The list of claimable ckBTC.</li><li><code>claimableLPTS</code>: The claimable LPTS amount.</li><li><code>claimableMPTS</code>: The claimable MPTS amount.</li><li><code>totalPendingCKBTC</code>: The total pending ckBTC amount.</li><li><code>totalWithdrawableCKBTC</code>: The total withdrawable ckBTC amount.</li></ul></li><li>The function returns the <code>datas</code> object.</li></ul></li></ol>

<p>In summary, the <code>getUserData</code> function retrieves various balances and claimable amounts for the caller, including ckBTC, lokBTC, MPTS, LPTS, staked shares, and claimable ckBTC, LPTS, and MPTS. It processes the claimable ckBTC to determine the total withdrawable and pending amounts and returns the data in a structured format.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.distributeLPTS"><code><span class="keyword">public func </span><span class="fnname">distributeLPTS</span>(<span class="parameter">amountSat_</span> : <span class="type">Nat</span>) : <span class="keyword">async </span>()</code></h4><p><p>The <code>distributeLPTS</code> function is a public shared asynchronous function that distributes a specified amount of LPTS (Liquidity Pool Token Shares) among users based on their shares. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>amountSat_</code> of type <code>Nat</code>, which represents the amount of LPTS to be distributed in satoshis.</li><li>The function returns <code>async ()</code>, indicating it performs asynchronous operations and returns no value.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Retrieve Shares</strong>:<ul><li>The function converts the entries of <code>sharesHash</code> to an array <code>sharesHash_</code>.</li></ul></li><li><strong>Calculate Total LPTS</strong>:<ul><li>The function calculates the total LPTS to be distributed by multiplying <code>amountSat_</code> by 10000 and stores it in the variable <code>totalLPTS</code>.</li></ul></li><li><strong>Loop Through Shares</strong>:<ul><li>The function iterates over each entry in <code>sharesHash</code>.</li></ul></li><li><strong>Calculate Shared LPTS</strong>:<ul><li>For each share, the function calculates the shared LPTS by multiplying the user's share by <code>totalLPTS</code> and dividing by <code>totalShares</code>.</li><li>The result is stored in the variable <code>sharedLPTS</code>.</li></ul></li><li><strong>Distribute Shared LPTS</strong>:<ul><li>The function checks if the user's wallet address already has claimable LPTS in <code>userClaimableLPTSHash</code>.</li><li>If the wallet address exists, it adds the <code>sharedLPTS</code> to the existing claimable LPTS.</li><li>If the wallet address does not exist, it sets the claimable LPTS to <code>sharedLPTS</code>.</li></ul></li></ol>

<p>In summary, the <code>distributeLPTS</code> function distributes a specified amount of LPTS among users based on their shares. It ensures that only admins can perform this operation, calculates the shared LPTS for each user, and updates the <code>userClaimableLPTSHash</code> with the new claimable LPTS for each user's wallet address.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.distributeMPTS"><code><span class="keyword">public func </span><span class="fnname">distributeMPTS</span>(<span class="parameter">amountSat_</span> : <span class="type">Nat</span>, <span class="parameter">to</span> : <span class="type">Text</span>) : <span class="keyword">async </span>()</code></h4><p><p>The <code>distributeMPTS</code> function is a public shared asynchronous function that distributes a specified amount of MPTS (Mining Pool Token Shares) to a specific user. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes two parameters:<ul><li><code>amountSat_</code>: The amount of MPTS to be distributed in satoshis (as <code>Nat</code>).</li><li><code>to</code>: The text representation of the user's wallet address (as <code>Text</code>).</li></ul></li><li>The function returns <code>async ()</code>, indicating it performs asynchronous operations and returns no value.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Calculate Total MPTS</strong>:<ul><li>The function calculates the total MPTS to be distributed by multiplying <code>amountSat_</code> by 10000 and stores it in the variable <code>amount_</code>.</li></ul></li><li><strong>Distribute MPTS</strong>:<ul><li>The function checks if the user's wallet address already has claimable MPTS in <code>userClaimableMPTSHash</code>.</li><li>If the wallet address exists (<code>?claimable</code>), it adds the <code>amount_</code> to the existing claimable MPTS and updates the hash map.</li><li>If the wallet address does not exist (<code>null</code>), it sets the claimable MPTS to <code>amount_</code> and updates the hash map.</li></ul></li></ol>

<p>In summary, the <code>distributeMPTS</code> function distributes a specified amount of MPTS to a specific user. It ensures that only admins can perform this operation, calculates the total MPTS to be distributed, and updates the <code>userClaimableMPTSHash</code> with the new claimable MPTS for the specified user's wallet address.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getMPTS"><code><span class="keyword">public func </span><span class="fnname">getMPTS</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <span class="type">Nat</span>)]</code></h4><p><p>The <code>getMPTS</code> function is a public shared asynchronous function that retrieves all entries of claimable MPTS (Mining Pool Token Shares) for users. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns an array of tuples <code>[(Text, Nat)]</code>, where each tuple contains a user's wallet address (as <code>Text</code>) and the corresponding claimable MPTS amount (as <code>Nat</code>).</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Retrieve Claimable MPTS</strong>:<ul><li>The function retrieves all entries from <code>userClaimableMPTSHash</code>, which is a hash map storing users' wallet addresses and their corresponding claimable MPTS amounts.</li></ul></li><li><strong>Convert to Array</strong>:<ul><li>The function converts the entries from the hash map into an array using <code>Iter.toArray(userClaimableMPTSHash.entries())</code>.</li></ul></li><li><strong>Return Claimable MPTS</strong>:<ul><li>The function returns the array of claimable MPTS entries.</li></ul></li></ol>

<p>In summary, the <code>getMPTS</code> function retrieves all entries of claimable MPTS for users, ensuring that only admins can perform this operation. It returns the data in an array of tuples format, where each tuple contains a user's wallet address and the corresponding claimable MPTS amount.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getLPTS"><code><span class="keyword">public func </span><span class="fnname">getLPTS</span>() : <span class="keyword">async </span>[(<span class="type">Text</span>, <span class="type">Nat</span>)]</code></h4><p><p>The <code>getLPTS</code> function is a public shared asynchronous function that retrieves all entries of claimable LPTS (Liquidity Pool Token Shares) for users. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns an array of tuples <code>[(Text, Nat)]</code>, where each tuple contains a user's wallet address (as <code>Text</code>) and the corresponding claimable LPTS amount (as <code>Nat</code>).</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Retrieve Claimable LPTS</strong>:<ul><li>The function retrieves all entries from <code>userClaimableLPTSHash</code>, which is a hash map storing users' wallet addresses and their corresponding claimable LPTS amounts.</li></ul></li><li><strong>Convert to Array</strong>:<ul><li>The function converts the entries from the hash map into an array using <code>Iter.toArray(userClaimableLPTSHash.entries())</code>.</li></ul></li><li><strong>Return Claimable LPTS</strong>:<ul><li>The function returns the array of claimable LPTS entries.</li></ul></li></ol>

<p>In summary, the <code>getLPTS</code> function retrieves all entries of claimable LPTS for users, ensuring that only admins can perform this operation. It returns the data in an array of tuples format, where each tuple contains a user's wallet address and the corresponding claimable LPTS amount.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.swapToMPTS"><code><span class="keyword">public func </span><span class="fnname">swapToMPTS</span>(<span class="parameter">amount</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>swapToMPTS</code> function is a public shared asynchronous function that swaps a specified amount of LPTS (Liquidity Pool Token Shares) to MPTS (Mining Pool Token Shares) for the caller. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>amount</code> of type <code>Nat</code>, which represents the amount of LPTS to be swapped to MPTS.</li><li>The function returns a <code>T.TransferRes</code> indicating the result of the swap.</li></ul></li><li><strong>Burn LPTS</strong>:<ul><li>The function calls <code>burnLPTS(message.caller, amount)</code> to burn the specified amount of LPTS for the caller and awaits its result.</li><li>The result is stored in the variable <code>burnLPTS_</code>.</li></ul></li><li><strong>Handle Burn Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the burn operation:<ul><li>If the burn is successful (<code>#success(number)</code>), it proceeds to mint MPTS.</li><li>If the burn fails (<code>#error(msg)</code>), it returns an error indicating the failure to burn LPTS.</li></ul></li></ul></li><li><strong>Mint MPTS</strong>:<ul><li>If the burn is successful, the function calls <code>MPTS.icrc1_transfer</code> to mint the specified amount of MPTS for the caller.</li><li>It specifies the transfer details, including:<ul><li><code>amount</code>: The amount of MPTS to be minted.</li><li><code>fee</code>: An optional fee of 0 units.</li><li><code>created_at_time</code>: Not set (null).</li><li><code>from_subaccount</code>: Not set (null).</li><li><code>to</code>: The destination wallet (the caller's wallet).</li><li><code>memo</code>: Not set (null).</li></ul></li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it returns <code>#success(number)</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it returns an error indicating the failure to mint MPTS.</li></ul></li></ul></li><li><strong>Return Default Error</strong>:<ul><li>If any other errors occur, the function returns a default error &quot;other&quot;.</li></ul></li></ol>

<p>In summary, the <code>swapToMPTS</code> function swaps a specified amount of LPTS to MPTS for the caller by first burning the LPTS and then minting the MPTS. It handles various error cases and returns the result of the swap operation. If the burn or mint operation fails, it returns an error indicating the failure. If the swap is successful, it returns the success result.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.swapToLPTS"><code><span class="keyword">public func </span><span class="fnname">swapToLPTS</span>(<span class="parameter">amount</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>swapToLPTS</code> function is a public shared asynchronous function that swaps a specified amount of MPTS (Mining Pool Token Shares) to LPTS (Liquidity Pool Token Shares) for the caller. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>amount</code> of type <code>Nat</code>, which represents the amount of MPTS to be swapped to LPTS.</li><li>The function returns a <code>T.TransferRes</code> indicating the result of the swap.</li></ul></li><li><strong>Burn MPTS</strong>:<ul><li>The function calls <code>burnMPTS(message.caller, amount)</code> to burn the specified amount of MPTS for the caller and awaits its result.</li><li>The result is stored in the variable <code>burnLPTS_</code>.</li></ul></li><li><strong>Handle Burn Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the burn operation:<ul><li>If the burn is successful (<code>#success(number)</code>), it proceeds to mint LPTS.</li><li>If the burn fails (<code>#error(msg)</code>), it returns an error indicating the failure to burn MPTS.</li></ul></li></ul></li><li><strong>Mint LPTS</strong>:<ul><li>If the burn is successful, the function calls <code>LPTS.icrc1_transfer</code> to mint the specified amount of LPTS for the caller.</li><li>It specifies the transfer details, including:<ul><li><code>amount</code>: The amount of LPTS to be minted.</li><li><code>fee</code>: An optional fee of 0 units.</li><li><code>created_at_time</code>: Not set (null).</li><li><code>from_subaccount</code>: Not set (null).</li><li><code>to</code>: The destination wallet (the caller's wallet).</li><li><code>memo</code>: Not set (null).</li></ul></li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it returns <code>#success(number)</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it returns an error indicating the failure to mint LPTS.</li></ul></li></ul></li><li><strong>Return Default Error</strong>:<ul><li>If any other errors occur, the function returns a default error &quot;other&quot;.</li></ul></li></ol>

<p>In summary, the <code>swapToLPTS</code> function swaps a specified amount of MPTS to LPTS for the caller by first burning the MPTS and then minting the LPTS. It handles various error cases and returns the result of the swap operation. If the burn or mint operation fails, it returns an error indicating the failure. If the swap is successful, it returns the success result.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.claimMPTS"><code><span class="keyword">public func </span><span class="fnname">claimMPTS</span>() : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>claimMPTS</code> function is a public shared asynchronous function that allows a user to claim their claimable MPTS (Mining Pool Token Shares). Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns a <code>T.TransferRes</code> indicating the result of the claim operation.</li></ul></li><li><strong>Check Claimable MPTS</strong>:<ul><li>The function checks if there are any claimable MPTS for the caller in <code>userClaimableMPTSHash</code> using <code>Principal.toText(message.caller)</code> as the key.</li><li>It uses a <code>switch</code> statement to handle the result:<ul><li>If the result is <code>?claimable</code>, it means there are claimable MPTS for the caller, and the amount is stored in the variable <code>claimable</code>.</li><li>If the result is <code>null</code>, it means there are no claimable MPTS for the caller, and the function returns <code>#error(&quot;no claimable&quot;)</code>.</li></ul></li></ul></li><li><strong>Perform Transfer</strong>:<ul><li>If there are claimable MPTS, the function calls <code>MPTS.icrc1_transfer</code> to transfer the claimable MPTS to the caller's account.</li><li>It specifies the transfer details, including:<ul><li><code>amount</code>: The amount of MPTS to be transferred.</li><li><code>fee</code>: An optional fee of 0 units.</li><li><code>created_at_time</code>: Not set (null).</li><li><code>from_subaccount</code>: Not set (null).</li><li><code>to</code>: The destination wallet (the caller's wallet).</li><li><code>memo</code>: Not set (null).</li></ul></li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it updates <code>userClaimableMPTSHash</code> to set the claimable amount to 0 for the caller and returns <code>#success(number)</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it returns <code>#error(&quot;error&quot;)</code>.</li></ul></li></ul></li></ol>

<p>In summary, the <code>claimMPTS</code> function allows a user to claim their claimable MPTS by transferring the claimable amount to the caller's account. It handles various error cases and returns the result of the claim operation. If the transfer is successful, it updates the claimable amount to 0 and returns the success result. If there are no claimable MPTS or the transfer fails, it returns an error indicating the failure.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.claimLPTS"><code><span class="keyword">public func </span><span class="fnname">claimLPTS</span>() : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>claimLPTS</code> function is a public shared asynchronous function that allows a user to claim their claimable LPTS (Liquidity Pool Token Shares). Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns a <code>T.TransferRes</code> indicating the result of the claim operation.</li></ul></li><li><strong>Check Claimable LPTS</strong>:<ul><li>The function checks if there are any claimable LPTS for the caller in <code>userClaimableLPTSHash</code> using <code>Principal.toText(message.caller)</code> as the key.</li><li>It uses a <code>switch</code> statement to handle the result:<ul><li>If the result is <code>?claimable</code>, it means there are claimable LPTS for the caller, and the amount is stored in the variable <code>claimable</code>.</li><li>If the result is <code>null</code>, it means there are no claimable LPTS for the caller, and the function returns <code>#error(&quot;no claimable&quot;)</code>.</li></ul></li></ul></li><li><strong>Perform Transfer</strong>:<ul><li>If there are claimable LPTS, the function calls <code>LPTS.icrc1_transfer</code> to transfer the claimable LPTS to the caller's account.</li><li>It specifies the transfer details, including:<ul><li><code>amount</code>: The amount of LPTS to be transferred.</li><li><code>fee</code>: An optional fee of 0 units.</li><li><code>created_at_time</code>: Not set (null).</li><li><code>from_subaccount</code>: Not set (null).</li><li><code>to</code>: The destination wallet (the caller's wallet).</li><li><code>memo</code>: Not set (null).</li></ul></li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it updates <code>userClaimableLPTSHash</code> to set the claimable amount to 0 for the caller and returns <code>#success(number)</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it returns <code>#error(&quot;error&quot;)</code>.</li></ul></li></ul></li></ol>

<p>In summary, the <code>claimLPTS</code> function allows a user to claim their claimable LPTS by transferring the claimable amount to the caller's account. It handles various error cases and returns the result of the claim operation. If the transfer is successful, it updates the claimable amount to 0 and returns the success result. If there are no claimable LPTS or the transfer fails, it returns an error indicating the failure.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getCounter"><code><span class="keyword">public func </span><span class="fnname">getCounter</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getTime"><code><span class="keyword">public func </span><span class="fnname">getTime</span>() : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setLOKBTC"><code><span class="keyword">public func </span><span class="fnname">setLOKBTC</span>(<span class="parameter">address</span> : <span class="type">Text</span>) : <span class="keyword">async </span>()</code></h4><p><p>The <code>setLOKBTC</code> function is a public shared asynchronous function that sets the address of the lokBTC token. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>address</code> of type <code>Text</code>, which represents the new address of the lokBTC token.</li><li>The function returns <code>async ()</code>, indicating it performs asynchronous operations and returns no value.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Set lokBTC Address</strong>:<ul><li>The function sets the global variable <code>lokBTC</code> to the provided <code>address</code>.</li></ul></li></ol>

<p>In summary, the <code>setLOKBTC</code> function sets the address of the lokBTC token, ensuring that only admins can perform this operation. It updates the global <code>lokBTC</code> variable with the new address provided as a parameter.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.setPoolCanister"><code><span class="keyword">public func </span><span class="fnname">setPoolCanister</span>(<span class="parameter">address</span> : <span class="type">Text</span>) : <span class="keyword">async </span>()</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.isNotPaused"><code><span class="keyword">public func </span><span class="fnname">isNotPaused</span>() : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setCKBTCPool"><code><span class="keyword">public func </span><span class="fnname">setCKBTCPool</span>(<span class="parameter">pool_</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Principal</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.setJwalletVault"><code><span class="keyword">public func </span><span class="fnname">setJwalletVault</span>(<span class="parameter">vault_</span> : <span class="type">Text</span>) : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.pauseCanister"><code><span class="keyword">public func </span><span class="fnname">pauseCanister</span>(<span class="parameter">pause_</span> : <span class="type">Bool</span>) : <span class="keyword">async </span><span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getCanisterTimeStamp"><code><span class="keyword">public func </span><span class="fnname">getCanisterTimeStamp</span>() : <span class="keyword">async </span><span class="type">Int</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.getCKBTCBalance"><code><span class="keyword">public func </span><span class="fnname">getCKBTCBalance</span>() : <span class="keyword">async </span><span class="type">Nat</span></code></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.Utxo"><span class="keyword">type </span><span class="type">Utxo</span> = { height : <span class="type">Nat32</span>; value : <span class="type">Nat64</span>; outpoint : { txid : <span class="type">Blob</span>; vout : <span class="type">Nat32</span> } }</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.UtxoStatus"><span class="keyword">type </span><span class="type">UtxoStatus</span> = {#ValueTooSmall : <span class="type">Utxo</span>; #Tainted : <span class="type">Utxo</span>; #Minted : { minted_amount : <span class="type">Nat64</span>; block_index : <span class="type">Nat64</span>; utxo : <span class="type">Utxo</span> }; #Checked : <span class="type">Utxo</span>}</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.PendingUtxo"><span class="keyword">type </span><span class="type">PendingUtxo</span> = { confirmations : <span class="type">Nat32</span>; value : <span class="type">Nat64</span>; outpoint : { txid : <span class="type">Blob</span>; vout : <span class="type">Nat32</span> } }</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="Miner.type.UpdateBalanceError"><span class="keyword">type </span><span class="type">UpdateBalanceError</span> = {#GenericError : { error_message : <span class="type">Text</span>; error_code : <span class="type">Nat64</span> }; #TemporarilyUnavailable : <span class="type">Text</span>; #AlreadyProcessing; #NoNewUtxos : { required_confirmations : <span class="type">Nat32</span>; pending_utxos : ?[<span class="type">PendingUtxo</span>]; current_confirmations : ?<span class="type">Nat32</span> }}</h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.updateckBTCBalance"><code><span class="keyword">public func </span><span class="fnname">updateckBTCBalance</span>() : <span class="keyword">async </span>()</code></h4><p><p>The <code>updateckBTCBalance</code> function is a public shared asynchronous function that updates the ckBTC balance by calling an external actor. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns <code>async ()</code>, indicating it performs asynchronous operations and returns no value.</li></ul></li><li><strong>Define Minter Actor</strong>:<ul><li>The function defines an actor <code>Minter</code> with the principal <code>&quot;mqygn-kiaaa-aaaar-qaadq-cai&quot;</code>.</li><li>The actor has a method <code>update_balance</code> that takes a record with an optional <code>subaccount</code> field of type <code>?Nat</code> and returns an asynchronous result of type <code>variant { #Ok : [UtxoStatus]; #Err : UpdateBalanceError }</code>.</li></ul></li><li><strong>Call Update Balance</strong>:<ul><li>The function calls <code>Minter.update_balance</code> with a record where <code>subaccount</code> is set to <code>null</code>.</li><li>The result of the call is stored in the variable <code>result</code>.</li></ul></li></ol>

<p>In summary, the <code>updateckBTCBalance</code> function updates the ckBTC balance by calling the <code>update_balance</code> method of an external actor. It defines the actor with the specified principal, calls the <code>update_balance</code> method with a <code>null</code> subaccount, and stores the result. The function performs this operation asynchronously and does not return any value.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.getCKBTCMinter"><code><span class="keyword">public func </span><span class="fnname">getCKBTCMinter</span>() : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.addLiquidity"><code><span class="keyword">public func </span><span class="fnname">addLiquidity</span>(<span class="parameter">amount_</span> : <span class="type">Nat</span>) : <span class="keyword">async </span><a href="types.html#type.AddLiquidityResult"><span class="type">T.AddLiquidityResult</span></a></code></h4><p><p>The <code>addLiquidity</code> function is a public shared asynchronous function that allows a user to add liquidity to the system by transferring ckBTC. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>amount_</code> of type <code>Nat</code>, which represents the amount of ckBTC to be added as liquidity.</li><li>The function returns a <code>T.AddLiquidityResult</code> indicating the result of the liquidity addition.</li></ul></li><li><strong>Pause Check</strong>:<ul><li>The function ensures that the system is not paused by calling <code>assert(_isNotPaused())</code>.</li></ul></li><li><strong>Transfer ckBTC</strong>:<ul><li>The function calls <code>transferCKBTCFrom(message.caller, amount_)</code> to transfer the specified amount of ckBTC from the caller's account.</li><li>The result of the transfer is stored in the variable <code>transferRes_</code>.</li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#success(x)</code>), it proceeds to update the shares and liquidity.</li><li>If the transfer fails (<code>#error(txt)</code>), it prints an error message and returns <code>#transferFailed(txt)</code>.</li></ul></li></ul></li><li><strong>Update Shares</strong>:<ul><li>If the transfer is successful, the function increments <code>totalShares</code> by <code>amount_</code>.</li><li>It initializes <code>updatedShare</code> to <code>amount_</code>.</li><li>The function checks if the caller already has shares in <code>sharesHash</code>:<ul><li>If the caller has shares (<code>?currentShare</code>), it updates the caller's share by adding <code>amount_</code> to the existing share and updates <code>sharesHash</code>.</li><li>If the caller does not have shares (<code>null</code>), it creates a new share entry for the caller with <code>amount_</code> and updates <code>sharesHash</code>.</li></ul></li></ul></li><li><strong>Update LOKBTC Shares</strong>:<ul><li>The function calls <code>LOKBTC.updateShare</code> to update the total shares and the caller's share in the LOKBTC canister.</li></ul></li><li><strong>Create Liquidity Record</strong>:<ul><li>The function creates a liquidity record with the following details:<ul><li><code>id</code>: The current value of <code>liquidityIndex</code>.</li><li><code>wallet</code>: The caller's principal.</li><li><code>time</code>: The current time.</li><li><code>amount</code>: The amount of ckBTC added as liquidity.</li><li><code>token</code>: The token type, set to &quot;CKBTC&quot;.</li></ul></li><li>The function adds the liquidity record to <code>addLiquidityHash</code>.</li></ul></li><li><strong>Update User Liquidity</strong>:<ul><li>The function checks if the caller already has liquidity entries in <code>userLiquidityHash</code>:<ul><li>If the caller has liquidity entries (<code>?list</code>), it appends the new liquidity index to the existing list and updates <code>userLiquidityHash</code>.</li><li>If the caller does not have liquidity entries (<code>null</code>), it creates a new entry for the caller with the new liquidity index.</li></ul></li></ul></li><li><strong>Increment Liquidity Index</strong>:<ul><li>The function increments <code>liquidityIndex</code> by 1.</li></ul></li><li><strong>Return Success</strong>:<ul><li>The function returns <code>#success(x)</code> to indicate that the liquidity addition was successful.</li></ul></li></ol>

<p>In summary, the <code>addLiquidity</code> function allows a user to add liquidity to the system by transferring ckBTC. It updates the user's shares and liquidity records, ensures that the system is not paused, and handles various error cases. If the liquidity addition is successful, it returns the success result; otherwise, it returns an error indicating the failure.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.claimCKBTC"><code><span class="keyword">public func </span><span class="fnname">claimCKBTC</span>() : <span class="keyword">async </span><a href="types.html#type.TransferRes"><span class="type">T.TransferRes</span></a></code></h4><p><p>The <code>claimCKBTC</code> function is a public shared asynchronous function that allows a user to claim their matured claimable ckBTC. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns a <code>T.TransferRes</code> indicating the result of the claim operation.</li></ul></li><li><strong>Check Matured Claimable ckBTC</strong>:<ul><li>The function checks if there are any matured claimable ckBTC for the caller in <code>userMaturedClaimableCKBTCHash</code> using <code>Principal.toText(message.caller)</code> as the key.</li><li>It uses a <code>switch</code> statement to handle the result:<ul><li>If the result is <code>?claimable</code>, it means there are matured claimable ckBTC for the caller, and the amount is stored in the variable <code>claimable</code>.</li><li>If the result is <code>null</code>, it means there are no matured claimable ckBTC for the caller, and the function returns <code>#error(&quot;claim not found&quot;)</code>.</li></ul></li></ul></li><li><strong>Perform Transfer</strong>:<ul><li>If there are matured claimable ckBTC, the function calls <code>CKBTC.icrc1_transfer</code> to transfer the claimable ckBTC to the caller's account.</li><li>It specifies the transfer details, including:<ul><li><code>amount</code>: The amount of ckBTC to be transferred.</li><li><code>fee</code>: An optional fee of 0 units.</li><li><code>created_at_time</code>: Not set (null).</li><li><code>from_subaccount</code>: Not set (null).</li><li><code>to</code>: The destination wallet (the caller's wallet).</li><li><code>memo</code>: Not set (null).</li></ul></li></ul></li><li><strong>Handle Transfer Result</strong>:<ul><li>The function uses a <code>switch</code> statement to handle the result of the transfer:<ul><li>If the transfer is successful (<code>#Ok(number)</code>), it updates <code>userMaturedClaimableCKBTCHash</code> to set the claimable amount to 0 for the caller and returns <code>#success(number)</code>.</li><li>If the transfer fails (<code>#Err(msg)</code>), it returns <code>#error(&quot;transfer error&quot;)</code>.</li></ul></li></ul></li></ol>

<p>In summary, the <code>claimCKBTC</code> function allows a user to claim their matured claimable ckBTC by transferring the claimable amount to the caller's account. It handles various error cases and returns the result of the claim operation. If the transfer is successful, it updates the claimable amount to 0 and returns the success result. If there are no matured claimable ckBTC or the transfer fails, it returns an error indicating the failure.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.requestRedeem"><code><span class="keyword">public func </span><span class="fnname">requestRedeem</span>(<span class="parameter">amount_</span> : <span class="type">Nat</span>) : <span class="keyword">async </span>{#success : <a href="types.html#type.Claimable"><span class="type">T.Claimable</span></a>; #error : <span class="type">Text</span>}</code></h4><p><p>The <code>requestRedeem</code> function is a public shared asynchronous function that allows a user to request the redemption of a specified amount of ckBTC. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes a single parameter <code>amount_</code> of type <code>Nat</code>, which represents the amount of ckBTC to be redeemed.</li><li>The function returns a variant type with two possible values: <code>#success : T.Claimable</code> if the operation is successful, or <code>#error : Text</code> if the operation fails.</li></ul></li><li><strong>Pause Check</strong>:<ul><li>The function ensures that the system is not paused by calling <code>assert(_isNotPaused())</code>.</li></ul></li><li><strong>Set Redemption Time</strong>:<ul><li>The function calculates the redemption time as the current time plus 24 hours and stores it in the variable <code>timeRedeem</code>.</li></ul></li><li><strong>Check User Shares</strong>:<ul><li>The function checks if the caller has enough shares in <code>sharesHash</code> using <code>Principal.toText(message.caller)</code> as the key.</li><li>It uses a <code>switch</code> statement to handle the result:<ul><li>If the result is <code>?share</code> and the user has enough shares (at least <code>amount_ + 10</code>), it proceeds with the redemption process.</li><li>If the result is <code>null</code> or the user does not have enough shares, it returns <code>#error(&quot;error&quot;)</code>.</li></ul></li></ul></li><li><strong>Update Shares</strong>:<ul><li>If the user has enough shares, the function updates the total shares and the user's shares:<ul><li>It decrements <code>totalShares</code> by <code>amount_ + 10</code>.</li><li>It updates the user's shares in <code>sharesHash</code> by subtracting <code>amount_ + 10</code> from the existing shares.</li><li>It calls <code>LOKBTC.updateShare</code> to update the total shares and the user's shares in the LOKBTC canister.</li></ul></li></ul></li><li><strong>Create Claim Object</strong>:<ul><li>The function creates a <code>T.Claimable</code> object with the following details:<ul><li><code>id</code>: The current value of <code>claimCKBTCId</code>.</li><li><code>amount</code>: The amount to be redeemed.</li><li><code>time</code>: The redemption time (<code>timeRedeem</code>).</li></ul></li></ul></li><li><strong>Update Claimable ckBTC Hash</strong>:<ul><li>The function checks if the caller already has claimable ckBTC entries in <code>userClaimableCKBTCHash</code>:<ul><li>If the caller has claimable entries (<code>?claimable_</code>), it updates the existing entries with the new claim object.</li><li>If the caller does not have claimable entries (<code>null</code>), it creates a new entry for the caller with the new claim object.</li></ul></li></ul></li><li><strong>Increment Claim ID</strong>:<ul><li>The function increments <code>claimCKBTCId</code> by 1.</li></ul></li><li><strong>Return Success</strong>:<ul><li>The function returns <code>#success(claimObject)</code> to indicate that the redemption request was successful.</li></ul></li></ol>

<p>In summary, the <code>requestRedeem</code> function allows a user to request the redemption of a specified amount of ckBTC by updating the user's shares and creating a claimable ckBTC entry. It ensures that the system is not paused, handles various error cases, and returns the result of the redemption request. If the request is successful, it returns the success result with the claim object; otherwise, it returns an error indicating the failure.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.whoCall"><code><span class="keyword">public func </span><span class="fnname">whoCall</span>() : <span class="keyword">async </span><span class="type">Text</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="Miner.rebaseLOKBTC"><code><span class="keyword">public func </span><span class="fnname">rebaseLOKBTC</span>() : <span class="keyword">async </span><span class="type">Text</span></code></h4><p><p>The <code>rebaseLOKBTC</code> function is a public shared asynchronous function that triggers a rebase operation for the lokBTC token. Here's a step-by-step description of how the function works:</p>
<ol><li><strong>Function Signature</strong>:<ul><li>The function is declared as <code>public shared (message)</code>, meaning it can be called by external actors.</li><li>It takes no parameters.</li><li>The function returns a <code>Text</code> value representing the result of the rebase operation.</li></ul></li><li><strong>Admin Check</strong>:<ul><li>The function ensures that the caller is an admin by calling <code>assert(_isAdmin(message.caller))</code>.</li></ul></li><li><strong>Trigger Rebase</strong>:<ul><li>The function calls <code>LOKBTC.forceRebase()</code> to trigger the rebase operation for the lokBTC token.</li><li>The result of the rebase operation is stored in the variable <code>a</code>.</li></ul></li><li><strong>Return Result</strong>:<ul><li>The function converts the result of the rebase operation from <code>Nat</code> to <code>Text</code> using <code>Nat.toText(a)</code> and returns it.</li></ul></li></ol>

<p>In summary, the <code>rebaseLOKBTC</code> function triggers a rebase operation for the lokBTC token, ensuring that only admins can perform this operation. It calls the <code>forceRebase</code> method on the <code>LOKBTC</code> actor and returns the result of the rebase operation as a <code>Text</code> value.</p>
</p></div><div class="declaration"><h4 class="function" id="Miner.transform"><code><span class="keyword">public func </span><span class="fnname">transform</span>(<span class="parameter">raw</span> : <a href="types.html#type.TransformArgs"><span class="type">T.TransformArgs</span></a>) : <span class="keyword">async </span><a href="types.html#type.CanisterHttpResponsePayload"><span class="type">T.CanisterHttpResponsePayload</span></a></code></h4><p></p></div><p></p></div></div></body></html>